[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "JuliaEpiHandbook",
    "section": "",
    "text": "About This Project\nThe purpose of this book is to create a similar document as the excellent EpiRHandbook for epidemiologist who are interested in becoming Julia language users. Most people in epidemiology and statistics use R, Stata, or SAS. There are still plenty of people who exclusively use Excel to great results. That’s OK, and I’m not trying to tell you that those options are bad and you should convert to Julia immediately. But there are some advantages that I think make it an attractive option for epidemiologists to consider.",
    "crumbs": [
      "About This Project"
    ]
  },
  {
    "objectID": "index.html#who-is-this-for-pre-requisite-knowledge",
    "href": "index.html#who-is-this-for-pre-requisite-knowledge",
    "title": "JuliaEpiHandbook",
    "section": "Who Is This For & Pre-Requisite Knowledge?",
    "text": "Who Is This For & Pre-Requisite Knowledge?\nBecause this book aims to provide ground-up instruction on using Julia as an epidemiologist, it does not assume any prior coding experience. Many people get started with Excel analysis, and this book tries to provide a new path that will be easier and more reliable for those individuals moving forward. As a result, the earlier chapters will lay out fundamental concepts of Julia and best practices for setting up a project, including concepts on version control and Git. But if you’ve got experience with R (or another language), then I hope to try and draw parallels and examples that will help speed up your learning.\nThe purpose of this book is not to teach you how to write the most performant code, though we will cover some key concepts as we go along, nor show you ever way to do a particular task. Neither is it’s purpose to teach you to become a Julia developer. There are many other resources that are better suited for those purposes, and I’ve tried to include links where appropriate. Instead, the goal is to help you get started with Julia, working through problems that you might encounter in your day-to-day work, providing you with the tools to carry out your work as an epidemiologist, and sufficient Julia knowledge to know how to research and think your way through other obstacles you may encounter. As a result, this book will make choices that prioritize readability and reproducibility over performance, because they are more important when you are getting started. Unlike Python, which takes the approach that there should only be one obvious way to complete a task, Julia provides the user with more flexibility because it is so fast that there are often multiple solutions that are similarly performant, and which one to use comes down to a stylistic choice. Where I make a deliberate choice, I will try to explain why I made that choice, and refer you to alternative approaches that you can explore on your own as you become more proficient with computational epidemiology and Julia.\nNot only will this book help you learn how to use Julia, but I hope that it will also help teach you how to think about problems that are relevant to you in a way that will help you solve them in Julia. Like everything in life, you will not be great at this immediately, and you may even be slower at problem solving with Julia that you are with your current tool. But, with practice, you will get better and faster, and you will soon be able to solve problems that you could not have solved before!",
    "crumbs": [
      "About This Project"
    ]
  },
  {
    "objectID": "index.html#built-with",
    "href": "index.html#built-with",
    "title": "JuliaEpiHandbook",
    "section": "Built With",
    "text": "Built With\n\nQuarto\nJulia",
    "crumbs": [
      "About This Project"
    ]
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "JuliaEpiHandbook",
    "section": "Contact",
    "text": "Contact\nYou can contact me via my email: “arnold dot crk at gmail dot com”.",
    "crumbs": [
      "About This Project"
    ]
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "JuliaEpiHandbook",
    "section": "Contributing",
    "text": "Contributing\nIf you see any issues, please open an Issue or Discussion on the book’s GitHub page. Or, if you know Git, you can open a Pull Request to fix the issue directly, which is even better!\n\n\n\n\n\n\nTip\n\n\n\nYou can directly go to the code for each page by clicking the “Edit this page on GitHub” link at the bottom of each page’s TOC on the right. This can be useful if you would like to point out an issue or propose a change.\n\n\nIf you are interested in contributing text, please email me and we can make it happen!",
    "crumbs": [
      "About This Project"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "JuliaEpiHandbook",
    "section": "Acknowledgements",
    "text": "Acknowledgements\n\nEpiRHandbook for inspiration",
    "crumbs": [
      "About This Project"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "JuliaEpiHandbook",
    "section": "License",
    "text": "License\nThis work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.",
    "crumbs": [
      "About This Project"
    ]
  },
  {
    "objectID": "motivations-background.html",
    "href": "motivations-background.html",
    "title": "What Is Julia and Why Should I Care",
    "section": "",
    "text": "Background\nNow that we’ve gotten a sense of what this book aims to achieve, let’s take a step back and talk about what Julia is, and why you should care. Julia is a relatively new free programming language that was first released in 2012 by some computational scientists at MIT, and has been growing in popularity ever since. It’s a general purpose language, meaning that it can be used for pretty much anything, but it’s particularly well suited for scientific computing, and is often compared to R, Python, and Matlab. There are plenty of reasons why you might want to learn Julia, but the main ones are that it’s fast, easy to learn (as far as coding goes), and has a great community. And with that, let’s dive in to the benefits and drawbacks of Julia!",
    "crumbs": [
      "Background",
      "What Is Julia and Why Should I Care"
    ]
  },
  {
    "objectID": "motivations-background.html#motivation",
    "href": "motivations-background.html#motivation",
    "title": "What Is Julia and Why Should I Care",
    "section": "Motivation",
    "text": "Motivation\n\nWhy write a book for Julia?\nWhat’s wrong with R, or Stata, or Python, or (insert your favourite language here)?\n\nExcellent questions. I use R every day and think it’s a great language for epidemiology, statistics, visualization, and many more things. But it’s not exactly a fast language. And for me, and plenty more epidemiologists, that can be a problem when working with large data sets or running simulations. Large data is less of an issue because package developers often have already rewritten the core code in a faster language, typically C++. But this is less that ideal if you want to look under the hood as it requires you to learn a second language (and C++ isn’t exactly known for being friendly to newcomers). The bigger issues, though, come when you need to write something from scratch, such as creating a large and complex simulation model, R is sometimes just too slow to actually run on your laptop in a reasonable time period, breaking up the development workflow. In this instance, you have two options: 1) suck it up and just hope your first attempt at the code was correct and don’t need to change anything, or 2) learn and rewrite your slow code in something faster. This is the classic “2 language problem”, and there are plenty of excellent articles on this, such as this Nature Methods article about Julia for Biologists, and this blog post from the creators of Julia.\n\nOK, but not everyone needs to run big simulations or work with big data. Why learn Julia over R in that case?\n\nAnother good question that covers a decent chunk of working epidemiologists. If you don’t need performance, I think it’s a slightly less compelling case, but there are still plenty of good reasons to think about learning Julia.\nFirstly, it has an excellent syntax and design structure that makes it one of the easier (and fun!) languages out there to learn. It’s incredibly helpful to be able to think in plain language and pretty much just implement that in code - for loops are quick so you don’t need to do mental gymnastics to think about how to vectorize your code. I know that’s a jargony term that might not mean anything to you, but in slower languages, you have to think about more abstract and unintuitive ways of implementing what you want, whereas much of your instincts are idiomatic in Julia i.e. are a fast and preferred implentation. This means that you can do more things more easily in Julia than you could in R, which has shoehorned many capabilities into it with varying degrees of success. Metaprogramming and multiple-dispatch are killer features that are core to how Julia works, and will eventually allow you to write simple and interpretable code that would require tons of if statements that result in hard-to-read code in other languages, such as R. And the package manager is excellent, making it so easy to create fully reproducible code, whereas R and Python almost seem to be it intentionally hard to do.\nSecondly, and this is a pretty big one, but Julia is a general purpose language whose syntax is rather similar to Python a lot of the time. Whether we like it or not, Python isn’t going anywhere. There’s a decent chance that at some point you will come across some Python code, or maybe even need to write some for a collaboration, and knowing Julia will make it pretty simple to pick up the key points, without needing to rely on using slow Python in your day-to-day life.\nFinally, if you need it, Julia is first-rate when it comes to scientific computing. A lot of aspects of epidemiology rely on differential equations, math, and increasingly, machine learning. Not only is there the excellent SciML ecosystem that houses a huge collection of state-of-the-art ODE solvers, but also, because Unicode symbols are valid code in Julia, you can literally write mathematical equations that you lifted out of a paper or book, and there’s a decent chance it’ll run with only minor modifications!",
    "crumbs": [
      "Background",
      "What Is Julia and Why Should I Care"
    ]
  },
  {
    "objectID": "motivations-background.html#it-cant-all-be-sunshine-and-roses",
    "href": "motivations-background.html#it-cant-all-be-sunshine-and-roses",
    "title": "What Is Julia and Why Should I Care",
    "section": "It Can’t All Be Sunshine and Roses",
    "text": "It Can’t All Be Sunshine and Roses\nCorrect. Julia is by no means perfect, and you will have to decide if the benefits outweigh the tradeoffs (I believe they do for a lot of us)!\nFirstly, while Julia has an active, friendly, and very enthusiatic community that is often willing to help when you get stuck, it is a relatively new language so support will be more limited than can be found in others. Related to this, not everything you will want to do will have a perfect pre-built package ready to go. Most of the time, this actually isn’t too big a deal as it’s either simple enough that you can quickly figure it out, or complex enough that you probably want to have ownership over the implementation, but occassionally it is genuinely an issue. Both of these issues, however, are improving rapidly as the Julia userbase grows and more people share their questions, expertise, and even turning solutions into packages that can be shared!\nThe next common stumbling block is related to performance. Despite what I said about it being a very fast language, it’s quite a bit slower at the start of a session than R or Python, for example. This is known as the “Time to first X” (TTFX) problem, and while everything will be almost instantaneous the second time you run it, it can be annoying. Thankfully, with the recent release of Julia 1.9.0, this is effectively a problem of the past, with most Julia sessions loading packages and creating your first plot within a few seconds, not a minute.\nAnd the last main issue with Julia is that packages aren’t always documented as clearly as in other languages, and debugging can be a painful experience. Every package is different, and while the Documenter.jl package does an excellent job of standardizing package documentation, unfortuately not everyone does a great job of writing robust tests and guides to help the user. Sometimes you just need to dig in the weeds to figure something out.\nBut, that’s part of the motivation for writing this book. For a lot of what we do as epidemiologists, we can work with very established packages that have solid code bases, so we won’t need to worry too much about the code quality as it’s already been tested by thousands of individuals. Instead, this book is to help guide someone new to Julia through the core tasks of epidemiology, and show you how to use the tools that exist in the community, but may have confusing documentation to someone new to the language, or even programming in general.",
    "crumbs": [
      "Background",
      "What Is Julia and Why Should I Care"
    ]
  },
  {
    "objectID": "technical-background.html",
    "href": "technical-background.html",
    "title": "Keywords, Code, and Other Formatting",
    "section": "",
    "text": "General Formatting\nThroughout the book, you’ll see some keywords, code, and other points that I’ll try to delineate with the following formatting:",
    "crumbs": [
      "Background",
      "Keywords, Code, and Other Formatting"
    ]
  },
  {
    "objectID": "technical-background.html#general-formatting",
    "href": "technical-background.html#general-formatting",
    "title": "Keywords, Code, and Other Formatting",
    "section": "",
    "text": "Note\n\n\n\nThis will be a note, and will be used to highlight important points, or to provide additional information.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThis will be used to highlight a useful tip.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis will provide a warning that you may get an unexpected result if you’re not careful.\n\n\n\ncode will be used to highlight code.\n{package} will be used to denote a specific package, e.g., {DataFrames} denotes the {DataFrames} package.\npackage.function() will be used to denote a function that is part of a specific package, e.g., DataFrames.subset() denotes the subset() function from the {DataFrames} package. Some languages use a different convention, such as package::function() in R, but I will use the package.function() syntax listed above as this is how you would use a function in Julia.\nkeywords will be used to highlight keywords and phrases, e.g., Git or GitHub.\n\nactions will also be highlighted in this way, e.g., commits or pushed being the result of the code git commit or git push\n\nfiles will be used to highlight file names, e.g., README.md or LICENSE.\nitalics will be used for emphasis in certain circumstances, e.g., signifying a question from an interactive terminal command.",
    "crumbs": [
      "Background",
      "Keywords, Code, and Other Formatting"
    ]
  },
  {
    "objectID": "technical-background.html#packages",
    "href": "technical-background.html#packages",
    "title": "Keywords, Code, and Other Formatting",
    "section": "Packages",
    "text": "Packages\nThroughout this book, I will use a number of packages to help with the analysis and visualization of data. For each section, I will provide a list of the packages used in a particular set of analyses at the top of the page. The Julia language has an excellent package manager that makes it easy to install and use packages, and also share projects and collaborate with others without running into issues regarding dependencies that often plagues other languages. In the next section, I will walk through the process of getting started with Julia, and therefore, the process of installing packages, but below you can see the full list of packages and the installed version of Julia used in this book.\n\nusing InteractiveUtils # Only required for notebook rendering\nversioninfo()\n\nJulia Version 1.10.4\nCommit 48d4fd48430 (2024-06-04 10:41 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: macOS (arm64-apple-darwin22.4.0)\n  CPU: 8 × Apple M1\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-15.0.7 (ORCJIT, apple-m1)\nThreads: 4 default, 0 interactive, 2 GC (on 4 virtual cores)\nEnvironment:\n  JULIA_NUM_THREADS = auto\n  JULIA_LOAD_PATH = @:@stdlib\n\n\n\nusing Pkg\nPkg.status()\n\nStatus `~/Documents/Repos/JuliaEpiHandbook/Project.toml`\n  [336ed68f] CSV v0.10.14\n⌃ [13f3f980] CairoMakie v0.12.2\n  [a93c6f00] DataFrames v1.6.1\n  [1313f7d8] DataFramesMeta v0.15.2\n  [634d3b9d] DrWatson v2.15.0\n⌃ [e9467ef8] GLMakie v0.10.2\n  [cd3eb016] HTTP v1.10.8\n⌃ [7073ff75] IJulia v1.24.2\n⌃ [c3a54625] JET v0.9.2\n  [0f8b85d8] JSON3 v1.14.0\n  [98e50ef6] JuliaFormatter v1.0.56\n  [70703baa] JuliaSyntax v0.4.8\n⌃ [295af30f] Revise v3.5.14\n  [db9b398d] Serde v3.1.0\n  [8ae5e7a9] TidierFiles v0.1.1\n⌃ [0656b61e] GLFW_jll v3.3.9+0\nInfo Packages marked with ⌃ have new versions available and may be upgradable.",
    "crumbs": [
      "Background",
      "Keywords, Code, and Other Formatting"
    ]
  },
  {
    "objectID": "technical-background.html#code-style",
    "href": "technical-background.html#code-style",
    "title": "Keywords, Code, and Other Formatting",
    "section": "Code Style",
    "text": "Code Style\nThere are many different ways to write code, and many different styles. But, in the interest of consistency and ease of collaboration, I would strongly recommend you use the {JuliaFormatter} package to format your code according to a specific style guide. In this book, I will use a lightly modified version of the Blue style guide, and you can see the specific changes to the default style in the .JuliaFormatter.toml file in the root directory of this book’s GitHub repository. In the next section, I will discuss how you can use the {JuliaFormatter} package to format your code.",
    "crumbs": [
      "Background",
      "Keywords, Code, and Other Formatting"
    ]
  },
  {
    "objectID": "install-julia.html",
    "href": "install-julia.html",
    "title": "Setting Up Julia",
    "section": "",
    "text": "Key Terms",
    "crumbs": [
      "Getting Started With Julia",
      "Setting Up Julia"
    ]
  },
  {
    "objectID": "install-julia.html#key-terms",
    "href": "install-julia.html#key-terms",
    "title": "Setting Up Julia",
    "section": "",
    "text": "VSCode: Visual Studio Code is a very popular open source code editor. It is free and available for Windows, Mac, and Linux. It is also the recommended editor for Julia and is well supported by the Julia community, with a number of extensions available to make the experience even better.\nREPL: The Julia REPL is the Julia Read-Eval-Print-Loop. This is the interactive command line interface for Julia. When you start Julia in the command line (terminal in Mac/Linux, command prompt in Windows), you are in the REPL, and it is a common way to interact with Julia.\nPackage: A package is a collection of code that can be used to extend the functionality of Julia and complete specific tasks. Packages are installed using the Pkg package manager.\nObject: An object is anything that you can create using code. This may be as simple as a number or a sentence (a string object), or as complex as a model or a plot.",
    "crumbs": [
      "Getting Started With Julia",
      "Setting Up Julia"
    ]
  },
  {
    "objectID": "install-julia.html#installing-julia",
    "href": "install-julia.html#installing-julia",
    "title": "Setting Up Julia",
    "section": "Installing Julia",
    "text": "Installing Julia\nThe first step to using Julia is to install it on your computer. There are a couple of different methods you can use to do this. The easiest way to get started is to directly download the latest stable Julia release from https://julialang.org/downloads/. This will get you up and running, but will be a bit more difficult to manage in the long run when you want to update Julia to newer versions.\nIf you are willing to put a tiny bit more effort in to save yourself time later, I would strongly recommend installing Julia using the Juliaup tool. This is a small cross-platform installer that can install Julia, as well as manage multiple versions on your computer, which is incredibly helpful when you want to update to a newer Julia version, or test out a new release candidate without breaking your existing Julia installation. You can find the full instructions here: https://github.com/JuliaLang/juliaup, but in brief, install Juliaup, and then run the following command in your terminal (Mac/Linux) or command prompt (Windows):\njuliaup add release # Installs the latest stable release\njuliaup default release # Not necessary with only one installed version, but sets the latest stable release as the default Julia version\nTo test that Julia has been installed correctly, open a terminal (Mac/Linux) or command prompt (Windows) and type julia. If Julia has been installed correctly, you should see something like the following:\n\n\n\nThe Julia REPL\n\n\nIf so, congratulations, you have successfully installed Julia, and you are now in the REPL. You could start working on Julia from here, but we’ll take a quick detour to install VSCode, which will make your life a lot easier. To quit the REPL, type exit() and press enter. You can also type Ctrl + D to exit the REPL.\n\nTrouble Shooting\nIf your Julia installation could not be found, it is likely an issue with your PATH variable. This is a variable that tells your computer where to look for programs when you type them into the command line. If you used Juliaup to install Julia and you are using a Mac or Linux, you might need to add the following line to your .bashrc or .zshrc file, depending of whether your computer uses bash or zsh.\nexport PATH=\"$HOME/.juliaup/bin/:$PATH\"\n\n\n\n\n\n\nTip\n\n\n\nIf you don’t know if your computer is using bash or zsh, you can check by typing echo $SHELL into the command line. This will print the shell that your computer is using; in my case /bin/zsh. You should also type ls -a ~ into the command line to see if you have an existing .bashrc or .zshrc file. If you do not have either, you can create the one relevant to your computer by typing touch ~/.bashrc or touch ~/.zshrc.\n\n\nIf you are using Juliaup on Windows, and installed using the recommended pathways (Windows store or winget command), you will need to edit your PATH variable using the following the steps detailed here, and make sure you have the following path:\n%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps",
    "crumbs": [
      "Getting Started With Julia",
      "Setting Up Julia"
    ]
  },
  {
    "objectID": "install-julia.html#installing-vscode",
    "href": "install-julia.html#installing-vscode",
    "title": "Setting Up Julia",
    "section": "Installing VSCode",
    "text": "Installing VSCode\nNow you have Julia installed, you need a code editor to write your Julia code in. There are a number of different options available, but the most popular is VSCode. You can download VSCode from https://code.visualstudio.com/download. Once you have VSCode installed, you will need to install the Julia extension. You can do this by opening this link and clicking “Install”, which will redirect you to VSCode to finish the install process. Alternatively, you can open VSCode, click the extensions icon in the left sidebar of VSCode (the one that looks like 4 blocks), and search for “Julia”.\n\n\n\nVSCode Julia Extension\n\n\nOnce you have installed the Julia extension, you’re ready to start writing Julia code!\nThe first thing you should do is open a Julia REPL within VSCode. To do this, open the VSCode command palette and type “Julia: Start REPL”.\n\n\n\n\n\n\nNote\n\n\n\nThe command palette is a really useful feature of VSCode that allows you to search for and run any command available in VSCode. You can open the command palette by pressing Ctrl + Shift + P on Windows or Linux, or Cmd + Shift + P on Mac. For more tips on how to navigate and use VSCode, see the VSCode documentation.\n\n\n\n\n\nStarting a Julia REPL in VSCode\n\n\nThis will open up a new section in VSCode that contains a Julia REPL within the “Integrated Terminal” of VSCode.\n\n\n\nIntegrated VSCode Julia Terminal\n\n\nYou can give Julia a quick spin by typing 1 + 1 into the REPL and pressing enter.\n\nTrouble Shooting\nIf your Julia installation could not be found by VSCode, but it works in the terminal, the VSCode Julia extension is having trouble find where Julia is installed.\nTo fix this, first, find your Julia installation. On Mac or Linux, you can do this by typing which julia into the terminal. On Windows, you can do this by typing where julia into the command prompt.\nIf you installed Julia using Juliaup, you should see something like the following:\n$ which julia\n\n/Users/username/.juliaup/bin/julia\nTake the output of this command and paste it into the VSCode settings. To do this, open the VSCode settings by clicking on the cog icon in the bottom left of the VSCode window, and then clicking “Settings”, or by using the command palette to navigate to “Preferences: Open Settings (UI)”. Here, search for “Julia Executable Path” and paste the output of the which/where julia command into the text box. this is a",
    "crumbs": [
      "Getting Started With Julia",
      "Setting Up Julia"
    ]
  },
  {
    "objectID": "install-julia.html#the-vscode-user-interface",
    "href": "install-julia.html#the-vscode-user-interface",
    "title": "Setting Up Julia",
    "section": "The VSCode User Interface",
    "text": "The VSCode User Interface\nHopefully at this point you have VSCode installed and the Julia extension working. Now’s let’s get familiar with VSCode itself, that way we can focus on learning Julia in the rest of the book, rather than getting stuck on the editor.\nA detailed description of the VSCode user interface is beyond the scope of this book (more details can be found here), but there are a few key features that you should be aware of.\n\n\nVideo\nVSCode User Interface\n\n\nAs you can see in the clip above, it is possible to move the main editing blocks around so you can have multiple files open at once (or even multiple views of the same file at different lines of code). Typically, I like to have my code open in one editing block and have the plots display to the right side of the screen.\nTo the left of the editing blocks is the primary sidebar, which contains a number of different panels. The first one, which I have open, is the “Explorer” panel, which shows the files and folders in the current Workspace. A Workspace in VSCode is a collection of folders and files that you want to group together into one project. This is a really useful feature of VSCode as it allows you to also have Workspace-specific settings, which can be useful when working on different projects. To get started with a new Workspace, all you have to do is open a folder in VSCode, as typically it’s a good rule of thumb to have one overarching folder per project. You can do this with Cmd + O on Mac or Ctrl + O on Windows or Linux, or by clicking “File” in the top left of the VSCode window and then clicking “Open Folder”. After doing so, you will see the folder name appear in the top of the “Explorer” panel, with all contained files and folders displayed below.\nFurther down in the sidebar, you will see there is a logo with three circles (which I click on in the video). This is the Julia extension, and will show you the Julia Workspace at the top, which contains every object that you have run and created. Below that is the Documentation section, which is where can search for and view the documentation for any Julia function or type (as long as the function is within one of the packages you have loaded). Finally, below that is the Plot Navigator section, which is where you can view the list of plots that you have created in Julia, and clicking on a plot number will update the plot viewer appropriately.\nAt the bottom of the screen, you will see the Integrated Terminal panel, which is where you can run Julia code, as well as the Problems panel, which will show you any errors or warnings that VSCode has detected in your code. Some other tools can be seen here, but they are not particularly important for now.\nFinally, at the very bottom of the screen is the Status Bar, which shows you the current branch of your git repository (if you have one), the current Julia environment, and some other miscellaneous information.\nOne thing you may have noticed in the video is that I used the keyboard shortcut Cmd + P to open different files within my Workspace. This is a really useful shortcut that allows you to quickly navigate to files, but you can also use it to navigate within a file. Typing @ will allow you to navigate to different symbols e.g. functions, variables, headings etc., and typing : will allow you to navigate to a specific line number in the file.",
    "crumbs": [
      "Getting Started With Julia",
      "Setting Up Julia"
    ]
  },
  {
    "objectID": "install-julia.html#bonus-set-up",
    "href": "install-julia.html#bonus-set-up",
    "title": "Setting Up Julia",
    "section": "Bonus Set Up",
    "text": "Bonus Set Up\n\nFonts\nIf you want to make your code look as good as possible, you should install a font that supports rendering of ligatures and Unicode characters, as Julia often uses them. Ligatures are special characters that are used to combine multiple characters into one. For example, ==&gt; is a ligature that with particular fonts will be rendered as a double arrow ⟹, which can look nicer and be easier to read. Examples of Unicode characters are Greek letters, such as θ, β, γ, σ, δ etc., which are often used in mathematical notation, and because Julia supports Unicode characters, you can use them in your code! This is very useful when coding up some mathematical formulae, as you can use the actual symbols rather than having to write out the name of the symbol (though this is not always recommended as it can make your code harder to read to those unfamiliar with the formulae). If you would like to use Unicode characters in your Julia code (this won’t necessarily work in other non-Julia files), you can start typing with \\, before typing the name of the symbol you want to use, and then pressing Tab to complete the symbol. For example, to add the θ symbol, you would type \\theta and then press Tab to complete the symbol.\nAll this being said, JuliaMono is a font designed specifically for Julia, and is a great choice for writing Julia code. You can more information at https://juliamono.netlify.app/, along with detailed installation instructions.",
    "crumbs": [
      "Getting Started With Julia",
      "Setting Up Julia"
    ]
  },
  {
    "objectID": "julia-basics.html",
    "href": "julia-basics.html",
    "title": "Julia Basics",
    "section": "",
    "text": "Key Terms",
    "crumbs": [
      "Getting Started With Julia",
      "Julia Basics"
    ]
  },
  {
    "objectID": "julia-basics.html#key-terms",
    "href": "julia-basics.html#key-terms",
    "title": "Julia Basics",
    "section": "",
    "text": "REPL: The Julia REPL is the Julia Read-Eval-Print-Loop. This is the interactive command line interface for Julia. When you start Julia in the command line (terminal in Mac/Linux, command prompt in Windows), you are in the REPL, and it is a common way to interact with Julia.\nPackage: A package is a collection of code that can be used to extend the functionality of Julia and complete specific tasks. Packages are installed using the Pkg package manager.\nVariable: A variable is a value or object that you have assigned a name. This may be as simple as a number or a sentence (a string variable), or as complex as a model or a plot.\nFunction: A function is a block of code that performs a specific task. Functions are called by name and can take arguments, before completing some computation and returning a value or object. Sometimes functions are written and called for their side effects, i.e. they do not directly return an object, but instead perform some action.\nMethod: A method is a specific implementation of a function.\nMultiple Dispatch: Multiple dispatch is a really exciting feature of Julia, but also one that is more difficult to understand for newer programmers. The basic premise is that in Julia, how functions behave depends on the types of the arguments that are passed to them. For example, the * operator (function) will behave differently if you try to multiply two integers (whole numbers), two floats (numbers with decimals), two matrices, any combination of these etc. Each of these different behaviors is a different method of the * function.",
    "crumbs": [
      "Getting Started With Julia",
      "Julia Basics"
    ]
  },
  {
    "objectID": "julia-basics.html#what-to-expect",
    "href": "julia-basics.html#what-to-expect",
    "title": "Julia Basics",
    "section": "What to Expect",
    "text": "What to Expect\nAs mentioned previously, this book (and page) is not meant to provide a ground-up description of everything you need to know about Julia. Instead, we’ll give an overview of some of the key concepts and features that should provide enough of an understanding that you can start using Julia with reasonable confidence. It’ll likely take a couple of passes through this page to really get a good understanding of the concepts, and that’s okay! It’s meant to act as a reference so you can come back to it later if you don’t understand something in the later, more-applied, sections. At the bottom of this page are some additional resources that you can use to gain a deeper understanding of Julia.",
    "crumbs": [
      "Getting Started With Julia",
      "Julia Basics"
    ]
  },
  {
    "objectID": "julia-basics.html#data-types-and-structures",
    "href": "julia-basics.html#data-types-and-structures",
    "title": "Julia Basics",
    "section": "Data Types and Structures",
    "text": "Data Types and Structures\nThere are a number of different data types and structures in Julia. Here are the key ones for your to be aware of.\nData Types:\n\nInteger\n\nWhole numbers\n\nFloat\n\nNumbers with decimals\n\nBoolean\n\ntrue or false (written in lowercase)\n\ntrue has equal value to 1 e.g. 1 == true\nfalse has equal value to 0 e.g. 0 == false\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn Julia, the == operator is used to check if two values are equal. It returns a boolean value, true or false, depending on whether the values are equal or not i.e. 1 == true returns true because 1 and true are equal! It is different to the = operator, which is used to assign a value to a variable (see this section below for more details on variables).\nIn Julia there is also the === operator, which is used to check if two values are identical. This is different to the == operator, which checks if two values are equal. For example, 1 == true returns true because 1 and true are equal, but 1 === true returns false because 1 and true are not identical (they are not stored in the same location in memory in the computer).\n\n\n\nChar\n\nA single character e.g. \"H\"\n\nString\n\nA sequence of characters e.g. \"Hello World!\"\n\n\nData Structures:\n\nArray\n\nAn array is a collection of values that are all the same type. Arrays can be one-dimensional (vectors), two-dimensional (matrices), or multi-dimensional. Arrays are mutable, meaning that they can be changed after they are created. An example of an array is [1, 2, 3]\n\nDataFrame\n\nA DataFrame is a special type of array created by the {DataFrames} package that is used to store tabular data. It is a collection of columns, where each column is an array of the same type.DataFrames are mutable, meaning that they can be changed after they are created.\n\nTuple\n\nA tuple is a collection of values that do not all have to be the same type. Tuples are very useful because they require very little memory, so are fast to create and access. They are also immutable, meaning that they cannot be changed after they are created, but because they are so fast to create, you can just create a new tuple with the values you want. An example of a tuple is (\"John\", 25, 1.8)\n\nDictionary\n\nA dictionary is a collection of key-value pairs that do not need to be of the same type. Dictionaries are mutable, and are very useful for storing data that you want to access by a key (i.e. name), rather than an index. For example, you might want to store a person’s name, age, and height e.g. Dict(\"name\" =&gt; \"John\", \"age\" =&gt; 25, \"height\" =&gt; 1.8)\n\nNamed Tuple\n\nA variant of the tuple is the named tuple. It is a cross between a tuple and a dictionary, and therefore has the benefits of being able to access values with keys instead of indices (though you use indices), but it is immutable and much smaller and faster than a dictionary. For our person example, a named tuple would look like (; name = \"John\", age = 25, height = 1.8). Note the ; at the beginning of the tuple - the use of semicolons is common in Julia to separate named arguments from unnamed arguments in functions, and while it is not essential to create a named tuple with length &gt; 1, it must be used for a named tuple with only one element ((name = \"John\", ) with a , after the pair could similar be used for 1-element named tuples).\n\nStructs\n\nA struct is a custom data type that you can create to store data. It is similar to a named tuple in that it is immutable and you can access values with keys instead of indices. One reason you may prefer to use a struct over a named tuple is that you can define methods for a struct (see the multiple dispatch section for more details). Creating structs are out of the scope of this book, but it is important to know that they exist and are a useful tool for organizing your data. If you want to learn more about structs, check out the documentation and this tutorial.\n\n\nIf you have an object and want to tell what type it is, you can use the typeof() function. If you have an array and want to tell what type the elements of the array are, you can use the eltype() function.",
    "crumbs": [
      "Getting Started With Julia",
      "Julia Basics"
    ]
  },
  {
    "objectID": "julia-basics.html#variables",
    "href": "julia-basics.html#variables",
    "title": "Julia Basics",
    "section": "Variables",
    "text": "Variables\nVariables really just stored pieces of information that you’ve given a name to. This is useful because it allows you to run a calculation, for example, and then save it for use later on. That way you don’t need to run the calculation again, you can just pull the value out of storage! A slightly different example is if you have a constant value that you use multiple times in your code, e.g. the size of a population. Rather than typing out the value every time you need it, you can just store it in a variable and use the variable name instead. This not only saves you time and makes your code more readable, but also can reduce the chance of making a mistake (e.g. if you accidentally type the wrong value when copying it to a new calculation).\n\nAssignment\nNow we know what variables are, let’s look at how to create them. As mentioned earlier, we use the = operator to assign a value to a variable. For example, if we wanted to create a variable called x and assign it the value 1, we would write x = 1. But we aren’t just restricted to numbers, we can assign any type of value to a variable. This includes strings, arrays, tuples, dictionaries, and structs.\nEarlier, when talking about data structures, we used the example of a person’s name, age, and height. Let’s see how we can create tuples, dictionaries, and dataframes to store this information.\n\nusing DataFrames # We need to load the DataFrames package to create a DataFrame\n\njohn_tuple = (\"John\", 25, 1.8)\njohn_ntuple = (name = \"John\", age = 25, height = 1.8)\njohn_dict = Dict(\"name\" =&gt; \"John\", \"age\" =&gt; 25, \"height\" =&gt; 1.8)\njohn_df = DataFrame(name = \"John\", age = 25, height = 1.8);\n\n\n\n\n\n\n\nNote\n\n\n\nWhen creating a dictionary, you can use the =&gt; operator to assign a value to a key. The key is always on the left, and the value is always on the right.\nAt the end of the test array assignment, we have a semicolon (;). This has nothing to do with the array, but is used to suppress the output of the assignment, so when we run the code, we don’t see the array printed to the screen.\n\n\nBecause a person’s name is a string, their age is an integer, and their height is a float, we cannot create an array to store this information, because arrays can only store values of the same type. To show how we can create and access arrays, let’s create a vector (1-D array) of multiple people’s names, as well as a random matrix (2-D array).\n\npeople_vec = [\"John\", \"Jane\", \"Joe\"]\ntest_arr = [1 2 3; 4 5 6; 7 8 9]\n\n3×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n 7  8  9\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen creating a matrix, you can use a semi-colon to separate rows in the matrix. One alternative is to specify the exact positions of each value e.g.\ntest_arr = [\n    1 2 3\n    4 5 6\n    7 8 9\n]\n\n\n\n\nAccessing Values\nTo access the value stored in a variable, we can often use indices. Julia, like R, is a 1-indexed language, meaning that the first element in an array has an index of 1, not 0 (like Python). In our examples, the first element of the objects we created is the person’s name, so we can access it with an index of 1.\n\njohn_tuple[1] # \"John\"\njohn_ntuple[1] # \"John\"\npeople_vec[1]\n\n\"John\"\n\n\nFor dataframes and multi-dimensional arrays, we have to make a slight modification to use a comma that separates the indices for each dimension. In an array/dataframe, the first index is the row number, and the second index is the column number. To access the element in the first row and the first column of the array, we would use the following code.\n\ntest_arr[1, 1]\njohn_df[1, 1]\n\n\"John\"\n\n\nIf we want to access an entire row or column, we can use the : operator. For example, if we want to access the first column of the array, we can use the following code.\n\ntest_arr[:, 1]\n\n3-element Vector{Int64}:\n 1\n 4\n 7\n\n\n\njohn_df[:, 1]\n\n1-element Vector{String}:\n \"John\"\n\n\nIf we want to access the first row of the array, we can use the following code.\n\ntest_arr[1, :]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn all cases where we used the : operator, we get a column vector as the output, not a single value, regardless of whether we are extracting a row or a column from the original array!\n\n\nHowever, none of these methods work for dictionaries. For dictionaries, you need to specify the key of the value you want to access.\n\njohn_dict[\"name\"]\n\n\"John\"\n\n\nYou can also use the key (or column name) to access the value in dataframes and named tuples.\n\njohn_df[1, :name] # The : operator before the column name turns it into a symbol that can be used to index the dataframe\njohn_df[1, \"name\"]\n\njohn_ntuple.name\n\n\"John\"",
    "crumbs": [
      "Getting Started With Julia",
      "Julia Basics"
    ]
  },
  {
    "objectID": "julia-basics.html#functions",
    "href": "julia-basics.html#functions",
    "title": "Julia Basics",
    "section": "Functions",
    "text": "Functions\n\nOverview\nFunctions are a core part of programming in Julia, and programming in general. A function is a block of code that performs a specific task. As has been said before, a function is like a recipe you might use to bake a cake. The recipe tells you what ingredients you need, how to combine them, and how long to bake them for. And like a recipe, a function can be used over and over again to produce the same result (assuming you have identical inputs). This is a really powerful concept, and helps make your work and research reproducible by breaking up your code into small, reusable, and understandable chunks. And because it is meant to be reused, it will save you time in cases when you need to do the same thing multiple times (you don’t want to have to write the same code over and over again)!\nSo let’s look at a simple example of a function in Julia, and use it to explore some of the key concepts of functions.\nSay we want to take a number, multiply it by 2, and then divide the result by 3. You could just write this out explicitly, but what if you want to do this for a bunch of different numbers? This is where a function comes in handy.\n\nfunction multiply_by_two_divide_by_three(x)\n    y = x * 2\n    z = y / 3\n    return z # it's good practice to explicitly return a value (or nothing in special cases)\nend\n\nmultiply_by_two_divide_by_three (generic function with 1 method)\n\n\nThis function takes a single argument, x, and then multiplies it by 2 and divides it by 3. The return keyword tells Julia what value to return from the function. It also tells Julia that the function is finished, and it will not execute any code after the return statement.\nLet’s try using this function.\n\nmultiply_by_two_divide_by_three(3)\n\n2.0\n\n\n\nmultiply_by_two_divide_by_three(10)\n\n6.666666666666667\n\n\nNote that in both of these examples, a floating point number is returned i.e., a number with decimals.\n\n\n\n\n\n\nNote\n\n\n\nWithout going into too much detail, it is good practice to give functions short, descriptive names. A good example would be cumsum() that is provided in Julia and calculates the cumulative sum of a vector.\nIf a function name is too long to write without separating the words, use snake case (words separated by underscores) e.g. multiply_by_two_divide_by_three() rather than leaving as a single block of text (multiplybytwodividebythree()), or using camelCase (multiplyByTwoDivideByThree()).\nIt is also good practice to add a docstring to your function. This is a short description of what the function does, and can be accessed by typing ? followed by the function name in the REPL. This means that you can quickly understand exactly what a function does without having to work your way through the code, really helping others who may read your code, but also future you if you revisit a project.\nAn example of adding a docstring to a function may be as simple as adapting our original code to look like the following.\n\"\"\"\n    multiply_by_two_divide_by_three(x)\n\nMultiply `x` by 2 and divide by 3.\n\"\"\"\nfunction multiply_by_two_divide_by_three(x)\n    y = x * 2\n    z = y / 3\n    return z\nend\nRead more about docstrings here.\n\n\n\n\nArguments & Keyword Arguments\nUnlike R, Julia makes a distinction between arguments and keyword arguments. Arguments are the values that are passed to a function. In the example function above, x is an argument. In Julia, arguments are positional, meaning that the order in which you pass them to a function matters. To see this in practice, let’s write a new function that takes two arguments, x and y, and multiplies them together after minusing one from argument x and adding one to argument y.\n\nfunction multiply_together_offsets(x, y)\n    z = (x - 1) * (y + 1)\n    return z\nend\n\nmultiply_together_offsets (generic function with 1 method)\n\n\nBecause Julia uses positional arguments, the following two function calls will return different values, even though the numbers 5 and 10 are used in both.\n\nmultiply_together_offsets(5, 10)\n\n44\n\n\n\nmultiply_together_offsets(10, 5)\n\n54\n\n\nKeyword arguments are arguments that are passed to a function by name. Generally speaking, keyword arguments are used to set default values for arguments that can be changed by the user. Let’s modify our multiply_together_offsets function to use keyword arguments.\n\nfunction multiply_together_offsets(x, y; offset_x = 1, offset_y = 1)\n    z = (x - offset_x) * (y + offset_y)\n    return z\nend\n\nmultiply_together_offsets (generic function with 1 method)\n\n\nWe have added two new arguments to the function, offset_x and offset_y, and given them default values of 1.\n\n\n\n\n\n\nTip\n\n\n\nIt is not necessary, but it is generally good style to place keyword arguments after all positional arguments, as well as separating them from positional arguments using a semi-colon (;), rather than a comma.\n\n\nNow, when we call the function, we can specify the values of these arguments by name.\n\nmultiply_together_offsets(5, 10)\n\n44\n\n\n\nmultiply_together_offsets(5, 10; offset_x = 2, offset_y = 3)\n\n39\n\n\n\n\nScope\nScope is a relatively complicated concept, but it is important to understand it in order to write functions that are easy to understand and debug. Scope refers to the visibility of variables within a function. In Julia, variables that are defined within a function are not visible outside of the function. The reverse is not true, however. Variables that are defined outside of a function are visible within the function, but cannot be modified.\nLet’s look at some examples.\n\nfunction add_one(x)\n    y = x + 1\n    return y\nend\n\nadd_one(5)\n\n6\n\n\n\ny\n\nUndefVarError: UndefVarError(:y)\nUndefVarError: `y` not defined\n\n\nIn this case, y is defined within the function add_one() i.e. is a local variable, and is therefore not visible outside of the function, but it can be used within the function!\n\nglobal_x = 5\n\nfunction print_global_x()\n    return println(global_x)\nend\n\nprint_global_x()\n\n5\n\n\nIn this example, global_x is defined outside of the function print_global_x(), and is therefore visible within the function, but it cannot be modified.\n\n\n\n\n\n\nWarning\n\n\n\nIt’s not good practice to access global variables in your functions. Instead, if you want to use a variable in your function, pass it as an argument.\n\n\n\nfunction modify_global_x()\n    global_x = 10\n    return global_x\nend\n\nmodify_global_x()\n\nglobal_x\n\n5\n\n\nHere, we have tried to modify global_x within the function modify_global_x(), but this has not worked. It looks like it worked when we called the function, but when we check the value of global_x outside of the function, it is still 5.\n\n\nMultiple Dispatch\nMultiple dispatch is the idea that the behavior of a function depends on the types of the arguments that are passed to it (as well as the number of arguments). To illustrate this, let’s go back to our original example function multiply_by_two_divide_by_three().\nIn the example above, we passed a single argument to the function, and it returned a floating point number. But what if we wanted to pass multiple numbers to the function, and have it return a vector of the results? We could do this by specifying another method of the function that accepts a tuple of numbers as an argument.\n\nfunction multiply_by_two_divide_by_three(x::Tuple)\n    y = zeros(Float64, length(x))\n    z = similar(y)\n\n    for i in eachindex(x)\n        y[i] = x[i] * 2\n        z[i] = y[i] / 3\n    end\n\n    return z\nend\n\nmultiply_by_two_divide_by_three (generic function with 2 methods)\n\n\nWe have defined a new method of the function (i.e., a new way of using the function) by specifying the type of the argument x as a tuple (::Tuple), and this is illustrated in the printout multiply_by_two_divide_by_three (generic function with 2 methods).\n\n\n\n\n\n\nNote\n\n\n\nYou don’t have to understand exactly what the code is doing here (but have a look at the for loop section if you’re interested). Neither is the code particularly efficient, but it’s a relatively readable way to illustrate the concept of multiple dispatch.\n\n\nNow let’s test out our new function method\n\nmultiply_by_two_divide_by_three((1, 2, 3))\n\n3-element Vector{Float64}:\n 0.6666666666666666\n 1.3333333333333333\n 2.0\n\n\nAnd we can see that the original method that just takes a single number as an argument still works.\n\nmultiply_by_two_divide_by_three(3)\n\n2.0\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIt is important to note that keyword arguments are not considered in multiple dispatch i.e., trying to define a new method of a function that differs only by keyword arguments will not create a new method, but just overwrite the old one. So if you want/need a new method, use positional arguments.",
    "crumbs": [
      "Getting Started With Julia",
      "Julia Basics"
    ]
  },
  {
    "objectID": "julia-basics.html#packages",
    "href": "julia-basics.html#packages",
    "title": "Julia Basics",
    "section": "Packages",
    "text": "Packages\nPackages are an essential part of the Julia ecosystem. You’ve already seen an example of a package in action: {DataFrames}. At their core, a package is a way for someone to share code, data, and documentation with other people. By design, Julia can’t do everything for everyone straight out of the box. Not only would it be an impossible task for the Julia developers to create a language that can do everything, but it would also be incredibly slow to load and run. Instead, packages extend the abilities of Julia by providing additional features (through functions) that are not included in the base language.\nThe {DataFrames} package, for example, creates a special data structure that is very easy to read, as well as providing a number of functions that make it easy to manipulate and analyze data.\nTo add a package to your Julia environment (project), you can use the add command in the package manager (accessed by pressing ] in the REPL). Then, you can use the using command to load the package into your current Julia session. See this page for more information in the context of setting up a new project.",
    "crumbs": [
      "Getting Started With Julia",
      "Julia Basics"
    ]
  },
  {
    "objectID": "julia-basics.html#control-flow",
    "href": "julia-basics.html#control-flow",
    "title": "Julia Basics",
    "section": "Control Flow",
    "text": "Control Flow\nControl flow refers to the order in which the statements in a program are executed. There are many different ways to control how a program is executed, but we will focus on the most common ones here. See the Julia documentation for more information.\n\nIf Statements\nIf statements are a way to control whether or not a block of code is executed, and fall under the general category of conditional evaluation (but I think “if statements” gives you a more intuitive sense of what we’re talking about in this section). There are many uses for conditional evaluation, so we’ll just show you some examples of how to use it, and you can explore further if you need to. The following is an example from the Julia documentation.\n\nfunction number_relations(x, y)\n    if x &lt; y\n        relation = \"less than\"\n    elseif x == y\n        relation = \"equal to\"\n    else\n        relation = \"greater than\"\n    end\n    return println(\"x is \", relation, \" y.\")\nend\n\nnumber_relations(2, 1)\n\nx is greater than y.\n\n\nIn this example we are using an if statement to determine the relationship between two numbers. It’s important to note that the conditional statements are evaluated in sequence, and the first one that evaluates to true is executed i.e. if then elseif then else in this example.\n\n\n\n\n\n\nNote\n\n\n\nelseif and else statements are both optional (i.e. just an if statement is valid), and you can have as many elseif statements as you like (including 0 i.e. just if and else statements).\n\n\n\nShort-Circuit Evaluation\nIf you want to check multiple conditions, you can use the && (and) and || (or) operators. These is known as short-circuit evaluation. For example, if we wanted to check if a number is between 0 and 10, we could do the following.\n\nfunction number_between(x)\n    if x &gt; 0 && x &lt; 10\n        println(\"x is between 0 and 10\")\n    else\n        println(\"x is not between 0 and 10\")\n    end\nend\n\nnumber_between(3)\n\nx is between 0 and 10\n\n\n\nnumber_between(11)\n\nx is not between 0 and 10\n\n\nIn number_between(3), x is greater than 0 and less than 10, so both conditions evaluate to true, and the code in the if statement is executed. In number_between(11), x is greater than 0, but not less than 10, so while the first condition evaluates to true, the second condition evaluates to false, so the code in the else statement is executed. This is important to understand - all conditions must evaluate to true for the code in the if statement to be executed! Based on this, try to think about why the following code also works.\n\nfunction number_between2(x)\n    if x &gt; 0 && ((x &gt; 10) == false)\n        println(\"x is between 0 and 10\")\n    else\n        println(\"x is not between 0 and 10\")\n    end\nend\n\nnumber_between2(3)\n\nx is between 0 and 10\n\n\n\n\n\nIteration\nIteration is a useful concept in programming, is a pretty intuitive way to think about many problems we come across in epidemiology (once you get used to it), and is very fast in Julia, so it’s worth spending some time to understand it. Do not expect to understand everything about iteration after reading this section, and you will likely need to come back to refer to it as you go through the book, but hopefully it will provide a good starting point for you to explore further.\n\nFor Loop\nThe most common way to iterate in Julia is using a for loop. We have already seen a for loop in the multiple dispatch section, but let’s look at a simpler example.\nLet’s say we want to calculate the sum of the numbers from 1 to 10 (cumulative sum) i.e. 1 + 2 + 3 + … + 10. Julia has an in-built function to do this (cumsum()), but let’s write our own function to do it using a for loop.\nThere are multiple ways we could write this function, but the most intuitive way is to go through each of the numbers in 1 to 10, and add them to a running total.\n\nfunction mycumsum(x)\n    y = 0 # Initialize our running total to 0\n\n    # For each number in x, add it to our running total\n    for i in x\n        y += x[i] # This is equivalent to y = y + x[i]\n    end\n\n    return y\nend\n\nmycumsum(1:10)\n\n55\n\n\n\n\nWhile Loop\nAnother way to iterate is using a while loop. The difference between a for loop and a while loop is that a for loop iterates over a sequence of values, whereas a while loop iterates until a condition is met. For example, let’s say we want to keep adding numbers to our running total until the total is greater than 100 (and stop counting). We might not know how many numbers we need to add to get to 100, so we can’t use a for loop, but we can use a while loop.\n\nfunction mycumsum2(x)\n    y = 0 # Initialize our running total to 0\n    i = 1 # Initialize our counter to 1\n\n    # While our running total is less than 100, add the next number to our running total\n    while y &lt; 100\n        y += x[i] # This is equivalent to y = y + x[i]\n        i += 1 # Update our counter so we can add the next number\n    end\n\n    return println(\"We added \", i, \" numbers to get to \", y)\nend\n\nmycumsum2(1:100)\n\nWe added 15 numbers to get to 105\n\n\n\n\n\n\n\n\nCaution\n\n\n\nwhile loops are very useful in many situations, but are more dangerous than for loops, because it’s easy to get stuck in an infinite loop. For example, if we accidentally started our cumulative sum between 0:100 and forgot to update our counter, we would never reach our condition of y &lt; 100, and the loop would never end. To avoid this, people often add break statements to their while loops, which will break out of the loop if a certain condition is met i.e. if we added 100 numbers and still haven’t reached 100, we can early exit out of the loop. Generally speaking, use a for loop if you can, and be careful when using while loops.\n\n\n\n\nMap\nAn alternative to loops is the map() function. If you are familiar with functional programming (or the {purrr} package and functions in R), the map() function will be easy to grasp. If not, not to worry as it’s just a different method of applying a set of functions to each element in a sequence. The main difference to be aware of is that each application of the function(s) happen independently from each other, so you can’t increment a counter and then update a value from the prior iteration of a loop.\nSay we want to calculate take an array of integers and return an array of their squares. We can use a for loop (shown in the folded code below) to do this. Or we could use the map() function, which accepts an array and a function as arguments.\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nfunction squares(x)\n    y = zeros(eltype(x), length(x))\n\n    for i in eachindex(x)\n        y[i] = x[i]^2\n    end\n    return y\nend\n\nsquares(1:10)\n\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n\n\n\n\n\n\nmap(x -&gt; x^2, 1:10)\n\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n\n\nIn the above example, we are using an anonymous function that takes each element of the array 1:10, assigns it to the variable x, and then squares it before returning it in a Vector. The map() function returns a vector of the same length as the input array, which is nice when we know want the output vector to be the same length as the input vector, as it removes the need for us to manually perform bounds checking.\nIn slightly more complicated scenarios, the anonymous function may become unwieldy. Here, we can either write a named function that we use in the map() function, or use a do block.\n\nfunction square_element(x)\n    return x^2\nend\n\nmap(square_element, 1:10)\n\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n\n\nMuch like the anonymous function, when we use a do block, we assign the elements being iterated over to a variable name that we can manipulate.\n\nmap(1:10) do x\n    x^2\nend\n\n10-element Vector{Int64}:\n   1\n   4\n   9\n  16\n  25\n  36\n  49\n  64\n  81\n 100\n\n\nThe do block is useful when we only want to perform some operations once, so it’s not necessary to create a named function. It is also very helpful when we want to pass multiple arguments to a function, as we will see.\nHere, we have two vectors of the same length and we want to perform element-wise addition i.e., add the first index of each vector together, the second elements, and so on. Doing this without the do block is possible, but much more cumbersome. Here, we can use the zip() function to combine the two vectors into a vector of tuples that can be iterated over by map().\n\nvec_a = 1:10\nvec_b = 11:20\n\nmap(zip(vec_a, vec_b)) do (a, b)\n    a + b\nend\n\n10-element Vector{Int64}:\n 12\n 14\n 16\n 18\n 20\n 22\n 24\n 26\n 28\n 30\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\ncollect(zip(vec_a, vec_b))\n\n10-element Vector{Tuple{Int64, Int64}}:\n (1, 11)\n (2, 12)\n (3, 13)\n (4, 14)\n (5, 15)\n (6, 16)\n (7, 17)\n (8, 18)\n (9, 19)\n (10, 20)\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nWithout the do block, we could write this. Note the , between the two closing parentheses in the anonymous function i.e., ...b),)\n\nmap(\n    ((a, b),) -&gt; a + b,\n    zip(vec_a, vec_b)\n)\n\n10-element Vector{Int64}:\n 12\n 14\n 16\n 18\n 20\n 22\n 24\n 26\n 28\n 30",
    "crumbs": [
      "Getting Started With Julia",
      "Julia Basics"
    ]
  },
  {
    "objectID": "julia-basics.html#additional-resources",
    "href": "julia-basics.html#additional-resources",
    "title": "Julia Basics",
    "section": "Additional Resources",
    "text": "Additional Resources\nI’d recommend checking out the following resources to learn more about Julia (roughly in descending order of preference due to complexity and target audience)\n\nScientific Computing for the Rest of Us\nJulia Academy\nJulia Data Science\nDoggo JL\nJulia Documentation\nQuantitative Economics with Julia\nThink Julia\nPumasAI Tutorials\nJulia For Economists Video Series\nAdvanced Scientific Computing: Producing Better Code",
    "crumbs": [
      "Getting Started With Julia",
      "Julia Basics"
    ]
  },
  {
    "objectID": "new-project.html",
    "href": "new-project.html",
    "title": "New Julia Project",
    "section": "",
    "text": "First Time Julia Setup\nNow that we have a better understanding of both Julia and the VSCode user interface, let’s create a new Julia project.\nFirst, open a fresh VSCode window. If you already happen to be in a workspace (check in the “Explorer” panel), you can click on the “File” menu in the top left of the VSCode window, and then click “New Window”. Now, open the Command Palette (keyboard shortcut Cmd + Shift + P on Mac or Ctrl + Shift + P on Windows or Linux) and type “Julia: Start REPL”. Doing this should open up the integrated terminal with the Julia REPL running. Type pwd() in the REPL and hit enter. It should return your home directory (i.e. /Users/&lt;your-username&gt; on Mac or C:\\Users\\&lt;your-username&gt; on Windows). From here we want to add a package called DrWatson to our Julia installation. To do this, type ] in the REPL and hit enter. This enters the Pkg REPL, which is a special REPL for managing Julia packages. Here you should see something like:\n(@v1.10) pkg&gt;\nNext, type add DrWatson and hit enter. This will add the DrWatson package to your Julia installation, and will allow us to easily create new Julia projects in a consistent way that works well for epidemiology projects (among others).",
    "crumbs": [
      "Getting Started With Julia",
      "New Julia Project"
    ]
  },
  {
    "objectID": "new-project.html#first-time-julia-setup",
    "href": "new-project.html#first-time-julia-setup",
    "title": "New Julia Project",
    "section": "",
    "text": "Note\n\n\n\nYou only have to follow these steps the first time after you download a new version of Julia and set it as your working version.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you’re still wondering why we’re bothering with the DrWatson package, you can read more about it below.",
    "crumbs": [
      "Getting Started With Julia",
      "New Julia Project"
    ]
  },
  {
    "objectID": "new-project.html#creating-a-folder-for-your-projects",
    "href": "new-project.html#creating-a-folder-for-your-projects",
    "title": "New Julia Project",
    "section": "Creating a Folder for Your Projects",
    "text": "Creating a Folder for Your Projects\nThe first thing we need to do is create a folder that will house all our individual project folders. To try and make your life easy, I would recommend you create this folder in your home directory, and call it Repos/ (or something similar). You can do this with Finder on Mac or File Explorer on Windows.",
    "crumbs": [
      "Getting Started With Julia",
      "New Julia Project"
    ]
  },
  {
    "objectID": "new-project.html#creating-a-julia-project",
    "href": "new-project.html#creating-a-julia-project",
    "title": "New Julia Project",
    "section": "Creating a Julia Project",
    "text": "Creating a Julia Project\nNow let’s create our first Julia project folder. To do this, go back to the Julia Pkg REPL and hit backspace. This will return you to the normal Julia REPL. Now we need to navigate to the folder you just created. To do this, type cd(\"path/to/your/project/folder\") and hit enter.\nFrom here, type using DrWatson and hit enter. This will load the DrWatson package into your Julia session so you can use its functions.\nTo create the project folder, type initialize_project(\"MyFirstProject\") and hit enter. This will create a new project folder MyFirstProject/ in the folder you navigated to earlier e.g., /Users/username/Documents/Repos/MyFirstProject/.\nNow you have a project folder, let’s open it in VSCode. In VSCode, click on the “File” menu in the top left of the VSCode window, and then click “Open Folder…”. From here, navigate to the project folder you just created and click “Open”. You VSCode window should refresh and you should now see the name of your project folder in the top center of the VSCode window (as well as in the top left of the “Explorer” panel).\nNow, if you try to open the Pkg REPL again, you will see something different. Instead it’ll say:\n\n(MyFirstProject) pkg&gt;\n\nYou’re ready to start adding packages to your project! I would recommend starting with following packages:\n\nRevise\nDrWatson\nDataFrames\nDataFramesMeta\nCSV\nIJulia\nJuliaFormatter\nCairoMakie\n\nAs before, to add a package, type add &lt;package-name&gt; and hit enter (you can add multiple packages at once by separating them with spaces e.g. add &lt;package-1&gt; &lt;package-2&gt;).",
    "crumbs": [
      "Getting Started With Julia",
      "New Julia Project"
    ]
  },
  {
    "objectID": "new-project.html#project-files",
    "href": "new-project.html#project-files",
    "title": "New Julia Project",
    "section": "Project Files",
    "text": "Project Files\nWhen you create a new Julia project, it creates two files in the project folder:\n\nProject.toml: this is a TOML file that contains the names and versions of all the packages you have added to your project\nManifest.toml: this is a TOML file that contains the names and versions of all the packages you have added to your project, as well as the names and versions of all the packages that those packages depend on. It is automatically generated by Julia, and you should not edit it manually.\n\nEdit the Project.toml file to add your name in the authors field at the top of the file (you will need to create this), so it looks something like this:\nname = \"MyFirstProject\"\nauthors = [\"My Name\"]\n\n[deps]\nCSV = \"336ed68f-0bac-5ca0-87d4-7b16caf5d00b\"\nCairoMakie = \"13f3f980-e62b-5c42-98c6-ff1f3baf88f0\"\nDataFrames = \"a93c6f00-e57d-5684-b7b6-d8193f3e46c0\"\nDataFramesMeta = \"1313f7d8-7da2-5740-9ea0-a2ca25f37964\"\nDrWatson = \"634d3b9d-ee7a-5ddf-bec9-22491ea816e1\"\nIJulia = \"7073ff75-c697-5162-941a-fcdaad2a7d2a\"\nJuliaFormatter = \"98e50ef6-434e-11e9-1051-2b60c6c9e899\"\nRevise = \"295af30f-e4ad-537b-8983-00126c2a3abe\"",
    "crumbs": [
      "Getting Started With Julia",
      "New Julia Project"
    ]
  },
  {
    "objectID": "new-project.html#creating-running-a-julia-script",
    "href": "new-project.html#creating-running-a-julia-script",
    "title": "New Julia Project",
    "section": "Creating & Running a Julia Script",
    "text": "Creating & Running a Julia Script\nTo create a Julia script in your project, click on the “File” menu in the top left of the VSCode window, and then click “New File”. Alternatively, you could use the keyboard shortcut Cmd + N on Mac or Ctrl + N on Windows or Linux. This will open a new file in the VSCode editor, which you can then save. Given we are using DrWatson, it is also good practice to save it in the scripts/ folder. You can save it with any file name you like, but it is good practice to save it with the .jl extension e.g., scripts/myscript.jl.\nAt this point, you can start writing your Julia code. Just make sure that the first two lines of the script are:\nusing DrWatson\nquickactivate(\"MyFirstProject\")",
    "crumbs": [
      "Getting Started With Julia",
      "New Julia Project"
    ]
  },
  {
    "objectID": "new-project.html#miscellaneous",
    "href": "new-project.html#miscellaneous",
    "title": "New Julia Project",
    "section": "Miscellaneous",
    "text": "Miscellaneous\n\nDrWatson Project Structure\nIt may not be immediately obvious why we need to use DrWatson to create our Julia projects. In fact, we don’t need to use DrWatson to create our Julia projects, but it does make our lives a lot easier as it provides a consistent project structure that is easy to navigate.\nFirstly, it creates the following folders and files in your project folder (copied from the DrWatson documentation):\n│projectdir          &lt;- Project's main folder. It is initialized as a Git\n│                       repository with a reasonable .gitignore file.\n│\n├── _research        &lt;- WIP scripts, code, notes, comments,\n│   |                   to-dos and anything in an alpha state.\n│   └── tmp          &lt;- Temporary data folder.\n│\n├── data             &lt;- **Immutable and add-only!**\n│\n├── plots            &lt;- Self-explanatory.\n├── notebooks        &lt;- Jupyter, Weave or any other mixed media notebooks.\n│\n├── papers           &lt;- Scientific papers resulting from the project.\n│\n├── scripts          &lt;- Various scripts, e.g. simulations, plotting, analysis,\n│   │                   The scripts use the `src` folder for their base code.\n│   └── intro.jl     &lt;- Simple file that uses DrWatson and uses its greeting.\n│\n├── src              &lt;- Source code for use in this project. Contains functions,\n│                       structures and modules that are used throughout\n│                       the project and in multiple scripts.\n│\n├── README.md        &lt;- Optional top-level README for anyone using this project.\n├── .gitignore       &lt;- by default ignores _research, data, plots, videos,\n│                       notebooks and latex-compilation related files.\n│\n├── Manifest.toml    &lt;- Contains full list of exact package versions used currently.\n└── Project.toml     &lt;- Main project file, allows activation and installation.\n                        Includes DrWatson by default.\nIn addition to the {DrWatson} produced directories, I like to create an out/ directory where all analysis outputs are created, e.g., the sims shown in the structure above, rather than saving them to the data/ directory, as {DrWatson} suggests. The reason for doing this is that it provides a very clear separation of input and output files, where inputs should never be modified, and outputs are files that should always be able to deleted and recreated using the code in the scripts. As a result, the final structure of the project looks like this:\n│projectdir          &lt;- Project's main folder. It is initialized as a Git\n│                       repository with a reasonable .gitignore file.\n│\n├── _research        &lt;- WIP scripts, code, notes, comments,\n│   |                   to-dos and anything in an alpha state.\n│   └── tmp          &lt;- Temporary data folder.\n│\n├── data             &lt;- **Immutable and add-only!**\n│   └── exp_raw      &lt;- Raw experimental data.\n│\n├── out              &lt;- **Immutable and add-only!**\n│   ├── exp_pro      &lt;- Data from processing experiments.\n│   └── sims         &lt;- Data resulting directly from simulations.\n│\n├── plots            &lt;- Self-explanatory.\n├── notebooks        &lt;- Jupyter, Weave or any other mixed media notebooks.\n│\n├── papers           &lt;- Scientific papers resulting from the project.\n│\n├── scripts          &lt;- Various scripts, e.g. simulations, plotting, analysis,\n│   │                   The scripts use the `src` folder for their base code.\n│   └── intro.jl     &lt;- Simple file that uses DrWatson and uses its greeting.\n│\n├── src              &lt;- Source code for use in this project. Contains functions,\n│                       structures and modules that are used throughout\n│                       the project and in multiple scripts.\n│\n├── README.md        &lt;- Optional top-level README for anyone using this project.\n├── .gitignore       &lt;- by default ignores _research, data, plots, videos,\n│                       notebooks and latex-compilation related files.\n│\n├── Manifest.toml    &lt;- Contains full list of exact package versions used currently.\n└── Project.toml     &lt;- Main project file, allows activation and installation.\n                        Includes DrWatson by default.\nAbove providing us with a useful project structure, DrWatson also provides us with a number of very helpful functions.\nFor one, it provides us with the quickactivate() function that allows us to activate our project and environment when we’re working in a script, so we can easily import all the packages we need, regardless of where the script is saved. This means that we don’t need to worry about activating our project in the REPL before we start working in a script. This may not sound meaningful, but it’s very easy to forget to activate your project in the REPL before you start working in a script, and then you end up with a bunch of errors because you haven’t actually imported the packages you need. To use this, make sure your first two lines of your script are always:\nusing DrWatson\nquickactivate(\"MyFirstProject\")\nAnd secondly, it provides us with convenient directory paths to the folders in our project. For example, if we want to access the data folder in our project, we can use the datadir() function, which will return the path to the data folder. Similarly, if we wanted to save a plot to the plots folder, we could use save(plotsdir(\"plot_object.png\"), plot_object) function to save the plot in plot_object to the plots folder.\nMore details about the DrWatson project structure and associated functions can be found here.\n\n\nNaming Files\nWhen naming files and folders, it is important to be consistent and descriptive. Ideally the name will contain no spaces, and you can use dashes to separate words. See this presentation by Jenny Bryan for more information on naming files and folders, but in short:\n\nKISS (Keep It Simple Stupid): use simple and consistent file names\n\nIt needs to be machine readable\nIt needs to be human readable\nIt needs to order well in a directory\nNo special characters and no spaces!\n\nUse YYYY-MM-DD date format\nUse - to delimit words and _ to delimit sections\n\ni.e. 2019-01-19_my-data.csv\n\nLeft-pad numbers\n\ni.e. 01_my-data.csv vs 1_my-data.csv\nIf you don’t, file orders get messed up when you get to double-digits",
    "crumbs": [
      "Getting Started With Julia",
      "New Julia Project"
    ]
  },
  {
    "objectID": "import-export.html",
    "href": "import-export.html",
    "title": "Importing and Exporting Files",
    "section": "",
    "text": "Overview\nUntil recently, Julia didn’t have a single package to import the majority of file types. However, with the increasing development efforts put into the {Tidier.jl} meta-packages, aimed at recreating the wildly popular set of {tidyverse} R packages in Julia, a new, convenient, single interface exists to the many excellent Julia I/O (input/output) packages. Here, we will explore some common workflows that can utilize the {TidierFiles.jl} package, though more details can be found in the documentation.",
    "crumbs": [
      "Getting Started With Julia",
      "Importing and Exporting Files"
    ]
  },
  {
    "objectID": "import-export.html#file-paths",
    "href": "import-export.html#file-paths",
    "title": "Importing and Exporting Files",
    "section": "File Paths",
    "text": "File Paths\nIf you’ve set up your project using {DrWatson}, you should have a number of useful helper functions for you to use in your project (after loading and activating the project with using DrWatson; quickactivate(Project)). Because you created a new folder for the project, Julia will create a Project.toml and a Manifest.toml file in your project folder. This does all the hard work of setting up relative paths, and making sure each project has it’s own list of packages and versions, avoiding any conflicts that may arise when you set up another project with similar packages. To make use of your code and project-specific packages, you simply need to activate the project using {DrWatson}’s quickactivate(\"Project\") function (or with ]activate . if you are in the correct directory).\nA relative filepath is simply the steps that need to be taken to find your target file from the current location, e.g., the active file. For example, you may have the following files in a project:\n│projectdir\n│\n├── data\n│   └── exp_raw.csv\n├── out\n│   └── exp_clean.parquet\n.\n.\n.\n├── scripts\n│   ├── cleaning.jl\n│   └── intro.jl\n.\n.\n.\n├── Manifest.toml\n└── Project.toml\nThe relative filepath of the exp_raw.csv data file from the intro.jl scripts file is ../data/exp_raw.csv. Here, ../ means look in the parent directory i.e., one directory up from the current location, with the rest pointing to the data/ directory and appropriate file. If you wanted to cleaning.jl file from intro.jl, the relative path would just be cleaning.jl (or alternatively ./cleaning.jl, where ./ means look in the current directory).\n\n\n\n\n\n\nNote\n\n\n\nGenerally you won’t need to refer to other script/ files as they shouldn’t contain functions that are used for calculations, only the scripts that utilize the functions defined in the src/ directory to produce your results. As we’ll come to later, Julia has been designed to make creating and working with packages very simple, which we will take full advantage to minimize the risk of files relying on each other in a circular fashion.\n\n\nAs mentioned, {DrWatson} provides convenience functions to simplify the process of locating files with relative paths. To load a file from the data/ folder, we need to include() it. This effectively finds the file and runs it, so everything defined in it is now available for use. In practice, we can simply use the command include(DrWatson.datadir(\"filename.jl\")) (or drop the DrWatson. package namespace if you brought {DrWatson} into the Main namespace with the using command - see here for more information about namespaces). This helpful function means that the file filename.jl can be loaded from within any file in your project without needing to use multiple ../ calls in the relative path, or specify the absolute filepath. It also means that you can send your code to the REPL and it will execute correctly, which is not a given as the directory that the REPL is started in is usually the project directory, and your current file may be in a subdirectory, so the relative paths to the file to load will be different.\n\n\n\n\n\n\nNote\n\n\n\nIn case you’re wondering what {DrWatson} is doing when it sets up these helper scripts, we can just have a look at the source code. The beauty of Julia is that its speed and expressiveness means that most Julia packages are written in pure Julia and don’t need to resort to lower-level languages for the internals!\nLooking at these lines in the source code, we can see that the projectdir() function is effectively a wrapper around the below code, with a check to make sure you have activated the project.\n\ndirname(Base.active_project())\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nBecause we created the out/ directory to save our processed data files to, it would be useful to have a similar helper function to {DrWatson}’s. We can do that very easily using the following function definition:\n\noutdir(args...) = DrWatson.projectdir(\"outdir\", args...)\n\nIncidentally, this is exactly how {DrWatson} defines it’s helper functions, and states that the functions can take any number of arguments and should join the directory path of the outdir/ and the function arguments. For example, outdir(\"simulation-files\") becomes path-to-project/outdir/simulation-files/.",
    "crumbs": [
      "Getting Started With Julia",
      "Importing and Exporting Files"
    ]
  },
  {
    "objectID": "import-export.html#tidierfiles-overview",
    "href": "import-export.html#tidierfiles-overview",
    "title": "Importing and Exporting Files",
    "section": "{TidierFiles} Overview",
    "text": "{TidierFiles} Overview\nAt the time of writing this section, the following file formats can be read and written to using {TidierFiles}:\n\nDelimited files\n\n.csv read_csv() and write_csv()\n.tsv read_tsv() and write_tsv()/write_table()\n.txt read_delim()\n\nExcel files read_xlsx() and write_xlsx()\n\n.xlsx\n\nSPSS files read_sav() and write_sav()\n\n.sav\n.por\n\nSAS files read_sas() and write_sas()\n\n.sas7bdat\n.xpt\n\nStata files read_dta() and write_dta()\n\n.dta\n\nArrow files read_arrow() and write_arrow()\n\n.arrow\n\nParquet files read_parquet() and write_parquet()\n\n.parquet\n\n\nReading and writing files is greatly simplified by using a common interface. To read a file, the general command is read_{format}(path-to-file.{format}) e.g., to read the exp_raw.csv file we would use the command read_csv(DrWatson.datadir(\"exp_raw.csv\")), and to read the exp_clean.parquet file we would use the command read_parquet(outdir(\"exp_raw.parquet\")). If you wish to use the values from the file, rather than just viewing them, you should assign them to a variable e.g. raw_df = read_csv(DrWatson.datadir(\"exp_raw.csv\")).\nWriting data to files is similarly simple, just replacing the read_ with write_, and passing in a DataFrame as the first argument. For example, to write a dataframe to a csv file, you simply use the command write_csv(raw_df, outdir(\"exp_clean.csv\")). Currently, all write functions require the use of a DataFrame object, and all read functions return a DataFrame object.",
    "crumbs": [
      "Getting Started With Julia",
      "Importing and Exporting Files"
    ]
  },
  {
    "objectID": "import-export.html#importing-files",
    "href": "import-export.html#importing-files",
    "title": "Importing and Exporting Files",
    "section": "Importing Files",
    "text": "Importing Files\n\nCSV Files from Internet URLs\nWith {TidierFiles} we can read data from URLs that are hosted on the web. To do this, we can use the read_csv() function and pass in the URL as the first argument, instead of a relative filepath. If the CSV or txt file is hosted on GitHub, you can navigate to the file in GitHub, open up the raw version, and pass the URL to the read_csv()/read_delim() function.\n\n\n\nusing TidierFiles\n\nread_csv(\n    \"https://raw.githubusercontent.com/TidierOrg/TidierFiles.jl/main/testing_files/csvtest.csv\";\n    skip = 1, # skip the first data row\n    n_max = 4, # only read the first 4 rows\n    col_select = [\"ID\", \"Score\"], # only read the \"ID\" and \"Score\" columns\n    missingstring = [\"4\"] # replace the value \"4\" with a missing value representation\n)\n\n4×2 DataFrame\n\n\n\nRow\nID\nScore\n\n\n\nInt64?\nInt64\n\n\n\n\n1\n2\n92\n\n\n2\n3\n77\n\n\n3\nmissing\n85\n\n\n4\n5\n95\n\n\n\n\n\n\n\n\nSpecific Excel Sheets & Ranges\nWhile it’s generally preferable to try and use non-proprietary data files that can be read by multiple software tools, such as .csv files, we are sometimes just provided with Excel files (or need to create them). In these situations, we can use {TidierFiles}‘s Excel functions’ to access data from specific sheets, or use the underlying {XLSX} package to read and write Excel files.\nTo read data from a sheet, we use the sheet = keyword argument of read_xlsx(path-to-file.xlsx, sheet = \"sheet-name\") function.\nOften, Excel sheets contain multiple tables, which may be related to one-another, but should be considered as their own separate entities. In these situations we can use the range = keyword argument of the read_xlsx() function to only read a portion of the Excel sheet.\n\n\nMissing Data\nFor delimited and Excel files, it is possible to specify how missing data should be handled on file reads. This is done using the missingstring = keyword argument of the read_{format}() functions, and defaults to \"\".\n\n\nSkipping Rows\nYour input data files may include a number of header rows that you do not want to include in the resulting dataframes, for example, a data dictionary that lists how values in the main table are coded. These rows can be skipped using the skip = keyword argument of all the read_{format}() functions.\n\n\nAutomated Programming Interfaces (APIs)\nSometimes an API is used to request and access data. Although it sounds very technical and complicated, an API is simply a (documented) method of interacting with a code and data source. In fact, we’ve already been using APIs throughout this book - every package provides a number of functions that are exported and available to end-users, which constitutes an API! Now that we’re a little more comfortable with the notion of an API, let’s see how it is often used in programming: to access data and information from websites.\nFor this example, we are going to use the Delphi COVIDcast API to collect COVID-19 death incidence data for the USA between 2020 and 2022. Since the beginning of the COVID-19 pandemic, the CMU Delphi team has been collating data from multiple sources and have provided an API for use by researchers and the public alike. As part of this project they have created and R package and a Python package to make interacting with the API easier. While there is not an equivalent Julia package, we can use the API documentation to assist us in downloading the data.\nExamining the instructions, we can see we need to use the following base URL: https://api.delphi.cmu.edu/epidata/covidcast/, and that there are a number of required query parameters. To see how we can piece together a query, the Delphi team have provided a number of examples we can use, along with our recently gained understanding of the API requirements. Looking at the examples we can see that each API query starts with ? and uses & to join the query parameters. To fill out the rest of the details, we will look at the example provided in the R package vignette, as this is what we are trying to recreate.\n\nbase_url = \"https://api.delphi.cmu.edu/epidata/covidcast/?\"\ndata_source = \"jhu-csse\"\nsignal = \"deaths_incidence_num\"\ngeo = \"nation\"\ngeo_values = \"us\"\ntime_type = \"day\"\ntime_values = \"20200415-20221231\"\n\nurl = base_url * \"data_source=\" * data_source *\n    \"&signal=\" * signal *\n    \"&time_type=\" * time_type *\n    \"&geo_type=\" * geo *\n    \"&time_values=\" * time_values *\n    \"&geo_values=\" * geo_values\n\n\"https://api.delphi.cmu.edu/epidata/covidcast/?data_source=jhu-csse&signal=deaths_incidence_num&time_type=day&geo_type=nation&time_values=20200415-20221231&geo_values=us\"\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nWe use the * character to perform string concatenation i.e., to join two or more strings together.\n\n\n\nNow that we have our API query, we need to make the request. API calls often use the HTTP internet protocol (the same one that you will be using to access this book), that utilize four verb: GET, SET, PUT, and POST, though we will just focus on GET. In Julia, the {HTTP} package is useful for making HTTP requests, in this case making use of the get() function. Examining the resulting response object, we can see there are a number of properties that can be accessed, but the ones we are interested in are the status and body. The status property provides us with the HTTP status code of the response, i.e., whether the request was successful or not. The body property provides us with the response body, which in this case is the actual data we are interested in.\n\nusing HTTP\n\nresponse = HTTP.get(url)\n\nHTTP.Messages.Response:\n\"\"\"\nHTTP/1.1 200 OK\nDate: Wed, 03 Jul 2024 22:24:02 GMT\nContent-Type: application/json\nTransfer-Encoding: chunked\nConnection: keep-alive\nSet-Cookie: ******\nSet-Cookie: ******\nServer: openresty/1.21.4.1\nvary: Accept-Encoding\nx-my-limit: 60\nx-my-remaining: 49\nx-my-reset: 1720047589\nretry-after: 2146\naccess-control-allow-origin: *\naccess-control-allow-methods: GET, POST, OPTIONS\naccess-control-allow-headers: DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range\naccess-control-expose-headers: Content-Length,Content-Range\ncontent-encoding: gzip\nStrict-Transport-Security: max-age=63072000\n\n{ \"epidata\": [{\"geo_value\":\"us\",\"signal\":\"deaths_incidence_num\",\"source\":\"jhu-csse\",\"geo_type\":\"nation\",\"time_type\":\"day\",\"time_value\":20200415,\"direction\":null,\"issue\":20230303,\"lag\":1052,\"missing_value\":0,\"missing_stderr\":5,\"missing_sample_size\":5,\"value\":2596.0,\"stderr\":null,\"sample_size\":null},{\"geo_value\":\"us\",\"signal\":\"deaths_incidence_num\",\"source\":\"jhu-csse\",\"geo_type\":\"nation\",\"time_type\":\"day\",\"time_value\":20200416,\"direction\":null,\"issue\":20230303,\"lag\":1051,\"missing_value\":0,\"missing_stderr\":5,\"missing_sample_size\":5,\"value\":2195.0,\"stderr\":null,\"sample_size\":null},{\"geo_value\":\"us\",\"signal\":\"deaths_incidence_num\",\"source\":\"jhu-csse\",\"geo_type\":\"nation\",\"time_type\":\"day\",\"time_value\":20200417,\"direction\":null,\"issue\":20230303,\"lag\":1050,\"missing_value\":0,\"missing_stderr\":5,\"missing_sample_size\":5,\"value\":2101.0,\"stderr\":null,\"sample_size\":null},{\"geo_value\":\"us\",\"signal\":\"deaths_incidence_num\",\"source\":\"jhu-csse\",\"geo_type\":\"nation\",\"time_type\":\"day\",\"time_value\":20200418,\"\n⋮\n280769-byte body\n\"\"\"\n\n\n\n\n\n\n\n\nTip\n\n\n\nAlthough it is good to know how to use string concatenation to create the API query, we can use the query keyword argument to pass a Dictionary of API parameters to the get() function, as shown in the documentation, which is a little cleaner and less prone to errors.\n\nresponse = HTTP.get(\n    base_url;\n    query = Dict(\n        \"data_source\" =&gt; \"jhu-csse\",\n        \"signal\" =&gt; \"deaths_incidence_num\",\n        \"geo\" =&gt; \"nation\",\n        \"geo_values\" =&gt; \"us\",\n        \"time_type\" =&gt; \"day\",\n        \"time_values\" =&gt; \"20200415-20221231\",\n    )\n)\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nIn practice, you would want to check the status code of the response to make sure that the request was successful, and if not, return an error to stop errors from being propagated throughout your code. In this case, we can just check the response code in the REPL using the following code which asserts that the status code is 200, which is commonly used to denote a successful API request. If the status code is 200, nothing will be printed, and if not, an error will be thrown. An example of an unsuccessful API request would be a 404 error, commonly used to denote that the requested resource does not exist (think about when you came across a 404 error when browsing the internet). HTTP status codes are not hard rules, but they are a standard that most people agree to follow. See here for a full list of HTTP status codes.\n\n@assert 200 == response.status\n\nSee this later discussion of Result types for more information on returning errors as values for a better way to handle possible (likely) sources of errors in your code.\n\n\n\nfirst(response.body, 10)\n\n10-element Vector{UInt8}:\n 0x7b\n 0x20\n 0x22\n 0x65\n 0x70\n 0x69\n 0x64\n 0x61\n 0x74\n 0x61\n\n\nUnfortunately the body property is a Vector{UInt8} and we can’t use it in our code, so we need to convert it to a String first before we can manipulate it for plotting purposes.\n\nbody = String(response.body)\n\n\"{ \\\"epidata\\\": [{\\\"geo_value\\\":\\\"us\\\",\\\"signal\\\":\\\"deaths_incidence_num\\\",\\\"source\\\":\\\"jhu-csse\\\",\\\"geo_type\\\":\\\"nation\\\",\\\"time_type\\\":\\\"day\\\",\\\"time_value\\\":20200415,\\\"direction\\\":null,\\\"issue\\\":20230303,\\\"lag\\\":1052,\\\"missing_value\\\":0,\\\"missing_stderr\\\":5,\\\"missing_sample_size\\\":5,\\\"value\\\":2596.0,\\\"std\" ⋯ 280231 bytes ⋯ \",\\\"source\\\":\\\"jhu-csse\\\",\\\"geo_type\\\":\\\"nation\\\",\\\"time_type\\\":\\\"day\\\",\\\"time_value\\\":20221231,\\\"direction\\\":null,\\\"issue\\\":20230224,\\\"lag\\\":55,\\\"missing_value\\\":0,\\\"missing_stderr\\\":5,\\\"missing_sample_size\\\":5,\\\"value\\\":26.0,\\\"stderr\\\":null,\\\"sample_size\\\":null}], \\\"result\\\": 1, \\\"message\\\": \\\"success\\\" }\"\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nOnce we convert the body to a String, the original data is deleted, so it cannot be used again. To confirm this, we can try calling it again.\n\nresponse.body\n\nUInt8[]\n\n\nThis is not normally an issue, but it’s something to be aware of. If you really wanted to make sure it was retained, you should instead use the command\n\nbody = String(copy(response.body))\n\n\n\n\nOnce we have downloaded the JSON data, we need to turn it into something that we can work with in Julia (i.e., a native data structure like a Dictionary). There are a few different options, but here we will use the {Serde.jl} package as it can convert many more file formats, not just JSON. {Serde.jl} is loosely based on the popular {serde.rs} rust library (in that it aims to achieve the same goals), standing for serializing and deserializing data (i.e. converting language specific objects into common formats and back). The function we are interested in here is Serde.parse_json(), which takes the JSON object and converts it into a Dictionary.\n\n\n\n\n\n\nNote\n\n\n\n\n\nJSON is a commonly used data format used to transfer data between web applications and APIs, as well as between many different programming languages. It is non-tabular and hierarchical, and looks a little like a Dictionary entry.\nAn example from the Delphi COVIDcast API documentation, which states that it returns a JSON object by default, is shown below:\n{\n  \"result\": 1,\n  \"epidata\": [\n    {\n      \"geo_value\": \"06001\",\n      \"time_value\": 20200407,\n      \"direction\": null,\n      \"value\": 1.1293550689064,\n      \"stderr\": 0.53185454111042,\n      \"sample_size\": 281.0245\n    },\n    ...\n  ],\n  \"message\": \"success\"\n}\n\n\n\n\nusing Serde\n\nparsed = Serde.parse_json(body)\n\nDict{String, Any} with 3 entries:\n  \"epidata\" =&gt; Any[Dict{String, Any}(\"issue\"=&gt;20230303, \"geo_type\"=&gt;\"nation\", \"…\n  \"message\" =&gt; \"success\"\n  \"result\"  =&gt; 1\n\n\nWe can see that {Serde.jl} has converted the JSON into a Dictionary, and the data we are interested in is in the epidata property, which is itself a Vector{Dict{String, Any}} (a vector of dictionaries that has strings for keys and any type for the values).\n\nepidata = parsed[\"epidata\"]\n\n991-element Vector{Any}:\n Dict{String, Any}(\"issue\" =&gt; 20230303, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 1052, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 2596.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20200415, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230303, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 1051, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 2195.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20200416, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230303, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 1050, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 2101.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20200417, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230303, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 1049, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 1936.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20200418, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230303, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 1048, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 1989.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20200419, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230303, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 1047, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 2256.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20200420, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230303, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 1046, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 2476.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20200421, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230309, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 1051, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 2461.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20200422, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230303, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 1044, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 2421.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20200423, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230309, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 1049, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 2063.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20200424, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n ⋮\n Dict{String, Any}(\"issue\" =&gt; 20230202, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 41, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 207.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20221223, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230210, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 48, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 22.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20221224, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230224, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 61, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 15.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20221225, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230217, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 53, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 29.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20221226, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230224, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 59, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 356.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20221227, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230224, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 58, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 990.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20221228, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230210, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 43, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 924.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20221229, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230224, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 56, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 216.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20221230, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n Dict{String, Any}(\"issue\" =&gt; 20230224, \"geo_type\" =&gt; \"nation\", \"lag\" =&gt; 55, \"sample_size\" =&gt; nothing, \"missing_sample_size\" =&gt; 5, \"value\" =&gt; 26.0, \"missing_stderr\" =&gt; 5, \"time_value\" =&gt; 20221231, \"geo_value\" =&gt; \"us\", \"signal\" =&gt; \"deaths_incidence_num\"…)\n\n\nNow we are finally ready to work with the data. The first thing we want to do it examine what the data looks like, and the easiest way to do this is to just examine the first element in the Vector.\n\nepidata[1]\n\nDict{String, Any} with 15 entries:\n  \"issue\"               =&gt; 20230303\n  \"geo_type\"            =&gt; \"nation\"\n  \"lag\"                 =&gt; 1052\n  \"sample_size\"         =&gt; nothing\n  \"missing_sample_size\" =&gt; 5\n  \"value\"               =&gt; 2596.0\n  \"missing_stderr\"      =&gt; 5\n  \"time_value\"          =&gt; 20200415\n  \"geo_value\"           =&gt; \"us\"\n  \"signal\"              =&gt; \"deaths_incidence_num\"\n  \"direction\"           =&gt; nothing\n  \"missing_value\"       =&gt; 0\n  \"time_type\"           =&gt; \"day\"\n  \"source\"              =&gt; \"jhu-csse\"\n  \"stderr\"              =&gt; nothing\n\n\nWe can double check that some of the other elements in the Vector also look the same, but assuming they do, we are really interested in the time_value and value properties as our goal is to plot the number of deaths over time. In order for us to plot the data, we need to create two vectors that can be passed to our plotting library: {GLMakie.jl}. Let’s do that with a loop.\n\nusing Dates\n\n# Create two empty vectors of the correct types\ndates = Vector{Date}(undef, length(epidata))\nvals = Vector{Float64}(undef, length(epidata))\n\n# Use pairs to ensure we have the correct length of the dictionary\n# and create a pair of indices and values that we can iterate over\nfor (index, dictionary) in pairs(epidata)\n    vals[index] = dictionary[\"value\"]\n    # using the `Date` constructor and the `dateformat` string macro we can convert\n    # the `time_value` into a `Date` format\n    dates[index] = Date(\"$(dictionary[\"time_value\"])\", dateformat\"yyyymmdd\")\nend\n\nNow we have our data in vector form, let’s plot it! Throughout this book we will use {GLMakie.jl} for plotting, and for the time being you can ignore the implementation details. In a later chapter we will cover the details of the plotting library.\n\nusing GLMakie\n\n# Create a minimal custom theme with bold, larger axis labels\nfunction theme_adjustments()\n    return Theme(;\n        fontsize = 16,\n        Axis = (;\n            xlabelsize = 20,\n            ylabelsize = 20,\n            xlabelfont = :bold,\n            ylabelfont = :bold,\n        ),\n        Colorbar = (;\n            labelsize = 20,\n            labelfont = :bold,\n        ),\n    )\nend\ncustom_theme = merge(theme_adjustments(), theme_minimal())\n\nset_theme!(\n    custom_theme;\n    fontsize = 16,\n    linewidth = 2,\n)\n\n# Create a lineplot of the data using GLMakie\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"Date\", ylabel = \"Deaths incidence\\nin the USA\")\nlines!(ax, dates, vals)\nfig\n\n\n\n\n\n\nR Files\nIt is possible that you will be working with others who use R. While it would be ideal if all of your data was saved to common formats, such as CSV, that is not always the case, with many R users choosing to save with R-specific formats. {TidierFiles.jl} does not have the functionality to read R files yet (though there are discussions about implementing it), we can use the {RData.jl} package to load rds and Rdata files. As noted in the README.md, we will also add and load the {CodecBzip2.jl} and {CodecXz.jl} packages for reading R data files that might use non-default compression methods.\nAs an example, we will load the fictional Malaria count data from the EpiRHandbook, and the Niamey data from Ottar Bjornstad’s “Epidemics: Models and Data in R” Book.\n\nusing RData\nimport CodecBzip2, CodecXz\nusing DrWatson\n\nmalaria = RData.load(DrWatson.datadir(\"malaria_facility_count_data.rds\"))\n\n┌ Warning: 0xd element in a 0x2 list, assuming it's the last element\n└ @ RData ~/.julia/packages/RData/L5u8v/src/readers.jl:138\n┌ Warning: 0xd element in a 0x2 list, assuming it's the last element\n└ @ RData ~/.julia/packages/RData/L5u8v/src/readers.jl:138\n\n\n3038×10 DataFrame3013 rows omitted\n\n\n\nRow\nlocation_name\ndata_date\nsubmitted_date\nProvince\nDistrict\nmalaria_rdt_0_4\nmalaria_rdt_5_14\nmalaria_rdt_15\nmalaria_tot\nnewid\n\n\n\nString\nDate\nDate\nString\nString\nInt32?\nInt32?\nInt32?\nInt32?\nInt32\n\n\n\n\n1\nFacility 1\n2020-08-11\n2020-08-12\nNorth\nSpring\n11\n12\n23\n46\n1\n\n\n2\nFacility 2\n2020-08-11\n2020-08-12\nNorth\nBolo\n11\n10\n5\n26\n2\n\n\n3\nFacility 3\n2020-08-11\n2020-08-12\nNorth\nDingo\n8\n5\n5\n18\n3\n\n\n4\nFacility 4\n2020-08-11\n2020-08-12\nNorth\nBolo\n16\n16\n17\n49\n4\n\n\n5\nFacility 5\n2020-08-11\n2020-08-12\nNorth\nBolo\n9\n2\n6\n17\n5\n\n\n6\nFacility 6\n2020-08-11\n2020-08-12\nNorth\nDingo\n3\n1\n4\n8\n6\n\n\n7\nFacility 6\n2020-08-10\n2020-08-12\nNorth\nDingo\n4\n0\n3\n7\n6\n\n\n8\nFacility 5\n2020-08-10\n2020-08-12\nNorth\nBolo\n15\n14\n13\n42\n5\n\n\n9\nFacility 5\n2020-08-09\n2020-08-12\nNorth\nBolo\n11\n11\n13\n35\n5\n\n\n10\nFacility 5\n2020-08-08\n2020-08-12\nNorth\nBolo\n19\n15\n15\n49\n5\n\n\n11\nFacility 7\n2020-08-11\n2020-08-12\nNorth\nSpring\n12\n7\n13\n32\n7\n\n\n12\nFacility 8\n2020-08-11\n2020-08-12\nNorth\nBolo\n7\n1\n20\n28\n8\n\n\n13\nFacility 9\n2020-08-11\n2020-08-12\nNorth\nSpring\n27\n8\n18\n53\n9\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n3027\nFacility 60\n2020-06-04\n2020-06-05\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n60\n\n\n3028\nFacility 21\n2020-06-05\n2020-06-05\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n21\n\n\n3029\nFacility 26\n2020-06-05\n2020-06-05\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n26\n\n\n3030\nFacility 2\n2020-06-04\n2020-06-05\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n2\n\n\n3031\nFacility 60\n2020-06-03\n2020-06-04\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n60\n\n\n3032\nFacility 4\n2020-06-04\n2020-06-04\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n4\n\n\n3033\nFacility 2\n2020-06-03\n2020-06-04\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n2\n\n\n3034\nFacility 22\n2020-06-03\n2020-06-04\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n22\n\n\n3035\nFacility 19\n2020-06-03\n2020-06-04\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n19\n\n\n3036\nFacility 24\n2020-06-03\n2020-06-04\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n24\n\n\n3037\nFacility 21\n2020-06-04\n2020-06-04\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n21\n\n\n3038\nFacility 21\n2020-06-03\n2020-06-03\nNorth\nBolo\nmissing\nmissing\nmissing\nmissing\n21\n\n\n\n\n\n\n\nniamey_dict = RData.load(DrWatson.datadir(\"niamey.rda\"))\n\nDict{String, Any} with 1 entry:\n  \"niamey\" =&gt; 31×13 DataFrame…\n\n\nAs we can see, the malaria RDS file loaded as expected, creating a nice DataFrame object that we manipulate. However the Niamey RData file is not in the DataFrame format, instead creating a Dictionary, so we will need to extract the DataFrame. This highlights the difference between RData and RDS files: RDS files can only contain one object, so are effectively a subset of the RData files. In both cases, we should confirm that all the variable type guesses are correct, as well as inspecting them for missingness, but this is something we will cover in later chapters.\n\nniamey = niamey_dict[\"niamey\"]\n\n31×13 DataFrame6 rows omitted\n\n\n\nRow\nabsweek\nweek\ntot_cases\ntot_mort\nlethality\ntot_attack\ncases_1\nattack_1\ncases_2\nattack_2\ncases_3\nattack_3\ncum_cases\n\n\n\nInt32\nInt32\nInt32\nInt32\nFloat64\nFloat64\nInt32\nFloat64\nInt32\nFloat64\nInt32\nFloat64\nInt32\n\n\n\n\n1\n1\n45\n11\n0\n0.0\n0.00142958\n11\n0.00316486\n0\n0.0\n0\n0.0\n11\n\n\n2\n2\n46\n12\n1\n8.33333\n0.00155955\n11\n0.00316486\n1\n0.000325975\n0\n0.0\n23\n\n\n3\n3\n47\n15\n0\n0.0\n0.00194943\n14\n0.004028\n1\n0.000325975\n0\n0.0\n38\n\n\n4\n4\n48\n14\n1\n7.14286\n0.00181947\n13\n0.00374029\n1\n0.000325975\n0\n0.0\n52\n\n\n5\n5\n49\n30\n0\n0.0\n0.00389887\n30\n0.00863143\n0\n0.0\n0\n0.0\n82\n\n\n6\n6\n50\n41\n1\n2.43902\n0.00532845\n34\n0.00978229\n7\n0.00228182\n0\n0.0\n123\n\n\n7\n7\n51\n31\n0\n0.0\n0.00402883\n29\n0.00834371\n1\n0.000325975\n1\n0.000868697\n154\n\n\n8\n8\n52\n59\n0\n0.0\n0.00766777\n55\n0.0158243\n3\n0.000977925\n1\n0.000868697\n213\n\n\n9\n9\n1\n63\n1\n1.5873\n0.00818762\n57\n0.0163997\n6\n0.00195585\n0\n0.0\n276\n\n\n10\n10\n2\n73\n0\n0.0\n0.00948725\n59\n0.0169751\n14\n0.00456365\n0\n0.0\n349\n\n\n11\n11\n3\n85\n0\n0.0\n0.0110468\n65\n0.0187014\n19\n0.00619353\n1\n0.000868697\n434\n\n\n12\n12\n4\n129\n1\n0.775194\n0.0167651\n107\n0.0307854\n19\n0.00619353\n3\n0.00260609\n563\n\n\n13\n13\n5\n113\n3\n2.65487\n0.0146857\n72\n0.0207154\n41\n0.013365\n0\n0.0\n676\n\n\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n⋮\n\n\n20\n20\n12\n893\n22\n2.46361\n0.116056\n465\n0.133787\n390\n0.12713\n38\n0.0330105\n5175\n\n\n21\n21\n13\n939\n25\n2.66241\n0.122035\n472\n0.135801\n412\n0.134302\n55\n0.0477783\n6114\n\n\n22\n22\n14\n829\n15\n1.80941\n0.107739\n370\n0.106454\n398\n0.129738\n61\n0.0529905\n6943\n\n\n23\n23\n15\n971\n21\n2.16272\n0.126193\n448\n0.128896\n444\n0.144733\n79\n0.068627\n7914\n\n\n24\n24\n16\n798\n12\n1.50376\n0.10371\n455\n0.13091\n258\n0.0841015\n85\n0.0738392\n8712\n\n\n25\n25\n17\n1015\n30\n2.95567\n0.131912\n507\n0.145871\n398\n0.129738\n110\n0.0955566\n9727\n\n\n26\n26\n18\n525\n6\n1.14286\n0.0682302\n238\n0.068476\n238\n0.077582\n49\n0.0425661\n10252\n\n\n27\n27\n19\n265\n7\n2.64151\n0.03444\n134\n0.0385537\n114\n0.0371611\n17\n0.0147678\n10517\n\n\n28\n28\n20\n192\n5\n2.60417\n0.0249528\n77\n0.022154\n99\n0.0322715\n16\n0.0138991\n10709\n\n\n29\n29\n21\n107\n2\n1.86916\n0.013906\n56\n0.016112\n42\n0.013691\n9\n0.00781827\n10816\n\n\n30\n30\n22\n63\n1\n1.5873\n0.00818762\n27\n0.00776829\n29\n0.00945328\n7\n0.00608088\n10879\n\n\n31\n31\n23\n1\n0\n0.0\n0.000129962\n0\n0.0\n1\n0.000325975\n0\n0.0\n10880\n\n\n\n\n\n\n\n\nNon-Tabular Data - {JLD2.jl}\nWe don’t always work with tabular data. For example, we may want to save the fit of a regression model to a file for later use, or we may just have a multi-dimensional array of epidemic simulations that we do not want to first transform into a matrix form. In these situations we need to use a different file format, and in Julia a common choice is the {JLD2.jl} package.\n{JLD2.jl} is a package that allows us to read and write files in a format that is compatible with the {HDF5.jl} package, written in pure Julia. HDF5 (Hierarchical Data Format v5) is a common file format that can be written and read by many programming languages, including a couple of R packages (‘{hdf5r}’, {rhdf5}), making it an especially good choice for polyglot teams.\n\n\n\n\n\n\nWarning\n\n\n\n\n\n{JLD2.jl} does it’s best to save custom structs in a manner that other languages will be able to interpret, it may not always work, so if cross-language compatibility is essential it is better to try and convert them into a common format, such as Arrays.\n\n\n\nTo load a JLD2 file we can use the load() or the jldopen() functions. load() works by reading the file and returning it as a Dictionary that can be saved to an object and indexed.\n\nusing JLD2\n\nexample_load = JLD2.load(datadir(\"example.jld2\"))\n\nDict{String, Any} with 2 entries:\n  \"dict\" =&gt; Dict{String, Any}(\"b\"=&gt;\"This is a string\", \"a\"=&gt;100)\n  \"x\"    =&gt; 100\n\n\n\nexample_load[\"dict\"]\n\nDict{String, Any} with 2 entries:\n  \"b\" =&gt; \"This is a string\"\n  \"a\" =&gt; 100\n\n\njldopen() works in a similar way to the XLSX.openxlsx() function in that it opens a file in a certain mode (r for read-only; r+ for read/write, failing if the file doesn’t exists; w for read/write, overwriting existing files; and a+ for read/write, preserving the file contents - amending). By default, jldopen() will open the file in read-only mode, but we are writing it explicitly for clarity in this example. Once the file has been opened, we can index it just like we do with a Dictionary.\n\nexample_jldopen = jldopen(datadir(\"example.jld2\"), \"r\")\n\nJLDFile /Users/cfa5228/Documents/Repos/JuliaEpiHandbook/data/example.jld2 (read-only)\n ├─🔢 dict\n └─🔢 x\n\n\n\nexample_jldopen[\"dict\"]\n\nDict{String, Any} with 2 entries:\n  \"b\" =&gt; \"This is a string\"\n  \"a\" =&gt; 100\n\n\nAlthough objects are accessed in the same way between the two methods, we can see that they are not the same thing by examining the types (though for our purposes at the moment it doesn’t matter).\n\ntypeof(example_load)\n\nDict{String, Any}\n\n\n\ntypeof(example_jldopen)\n\nJLD2.JLDFile{JLD2.MmapIO}\n\n\n\n\n\n\n\n\nWarning\n\n\n\nOnce you have finished reading/writing a file with with jldopen() you need to close it. If you don’t, you will not be able to reference it again. For example, you may have multiple files that reference the same data file, but you are using the same long-running REPL (which is usually recommended in Julia development). To do this, use close() to close the file.\n\nclose(example_jldopen)\n\nThe close() function is not necessary if you use the load() function.",
    "crumbs": [
      "Getting Started With Julia",
      "Importing and Exporting Files"
    ]
  },
  {
    "objectID": "import-export.html#exporting-files",
    "href": "import-export.html#exporting-files",
    "title": "Importing and Exporting Files",
    "section": "Exporting Files",
    "text": "Exporting Files\n\nSpecific Excel Sheets\nIf we want to write data to a specific sheet, we cannot use the {TidierFiles} excel functions. More information on how this can be accomplished can be found at the documentation of the {XLSX} package, but in brief, you must open up an excel file in either w (write) or rw (read-write) mode, depending on whether the file already exists, before setting the sheet’s values equal to the data you wish to add to the sheet.\nAn example of creating a new spreadsheet can from the documentation is shown below:\n\nXLSX.openxlsx(\"my_new_file.xlsx\", mode=\"w\") do xf\n    sheet = xf[1]\n    XLSX.rename!(sheet, \"new_sheet\")\n    sheet[\"A1\"] = \"this\"\n    sheet[\"A2\"] = \"is a\"\n    sheet[\"A3\"] = \"new file\"\n    sheet[\"A4\"] = 100\n\n    # will add a row from \"A5\" to \"E5\"\n    sheet[\"A5\"] = collect(1:5) # equivalent to `sheet[\"A5\", dim=2] = collect(1:4)`\n\n    # will add a column from \"B1\" to \"B4\"\n    sheet[\"B1\", dim=1] = collect(1:4)\n\n    # will add a matrix from \"A7\" to \"C9\"\n    sheet[\"A7:C9\"] = [ 1 2 3 ; 4 5 6 ; 7 8 9 ]\nend\n\n\n\n\n\n\n\nNote\n\n\n\nIf you are not already familiar with do blocks, don’t worry, they are relatively simple. The Excel file is being created and assigned to the xf variable, which can then be manipulated with an anonymous function that has its own scope. You can use the do block when using the map() function, as shown earlier.\n\n\n\n\nNon-Tabular Data - {JLD2.jl}\nAs mentioned earlier, we may want to save non-tabular data to a file. In these situations, we can use the {JLD2.jl} package, and there are two functions that we can use to do this. Let’s recreate the jld2 file from earlier.\n\ndict = Dict(\"a\" =&gt; 100, \"b\" =&gt; \"This is a string\")\nx = 100\n\njldsave(datadir(\"example.jld2\"); dict, x)\n\nWe can also rename the objects to be saved with the keyword arguments.\n\njldsave(datadir(\"example_rename.jld2\"); my_dict = dict, x)\nload(datadir(\"example_rename.jld2\"))\n\nDict{String, Any} with 2 entries:\n  \"my_dict\" =&gt; Dict{String, Any}(\"b\"=&gt;\"This is a string\", \"a\"=&gt;100)\n  \"x\"       =&gt; 100\n\n\nThe alternative method is to open up the file in read/write mode and edit it directly.\n\n\n\n\n\n\nNote\n\n\n\n\n\nIn this case, we have not created an object for the file, using a do block instead. To close the file, we need to use the close() function at the end of the block.\n\n\n\n\njldopen(datadir(\"example.jld2\"), \"w\") do file\n    file[\"dict\"] = dict\n    file[\"x\"] = x\n\n    close(file)\nend\n\nThe advantage of this method is we can create groups, i.e., create a folder-like structure within the file to group objects.\n\njldopen(datadir(\"example_group.jld2\"), \"w\") do file\n    group_1 = JLD2.Group(file, \"group_1\")\n    # equivalent to writing file[\"group_1/dict\"] = dict\n    # and file[\"group_1\"][\"dict\"] = dict\n    group_1[\"dict\"] = dict\n    group_1[\"x\"] = x\n\n    group_2 = JLD2.Group(file, \"group_2\")\n    group_2[\"string\"] = \"This exists in group 2\"\n\n    close(file)\nend\n\n\nload(datadir(\"example_group.jld2\"))\n\nDict{String, Any} with 3 entries:\n  \"group_1/x\"      =&gt; 100\n  \"group_1/dict\"   =&gt; Dict{String, Any}(\"b\"=&gt;\"This is a string\", \"a\"=&gt;100)\n  \"group_2/string\" =&gt; \"This exists in group 2\"",
    "crumbs": [
      "Getting Started With Julia",
      "Importing and Exporting Files"
    ]
  },
  {
    "objectID": "todo.html",
    "href": "todo.html",
    "title": "TODO List",
    "section": "",
    "text": "Data Management",
    "crumbs": [
      "TODO",
      "TODO List"
    ]
  },
  {
    "objectID": "todo.html#data-management",
    "href": "todo.html#data-management",
    "title": "TODO List",
    "section": "",
    "text": "Importing data\n\nCSV\nExcel\nR data\n{TidierFiles.jl}\nAPI with {HTTP.jl} and {Serde.jl}\n{JLD2.jl}/{HDF5.jl}\n\nExporting data\n\n{JLD2.jl}/{HDF5.jl}\n\nCleaning data",
    "crumbs": [
      "TODO",
      "TODO List"
    ]
  },
  {
    "objectID": "todo.html#analyses",
    "href": "todo.html#analyses",
    "title": "TODO List",
    "section": "Analyses",
    "text": "Analyses\n\nDescriptive statistics\nUnivariate analysis\nMultivariate analysis & regression\nMissing data\nStandardized rates\nTime series and outbreak detection\nEpidemic modeling\nSpatial analysis\nContact tracing\nSurvival analysis\nMixed effects models",
    "crumbs": [
      "TODO",
      "TODO List"
    ]
  },
  {
    "objectID": "todo.html#data-visualization",
    "href": "todo.html#data-visualization",
    "title": "TODO List",
    "section": "Data Visualization",
    "text": "Data Visualization\n\n{CairoMakie} basics\n{CairoMakie} tips\nInteractive plots with {GLMakie}\n{AlgebraOfGraphics}",
    "crumbs": [
      "TODO",
      "TODO List"
    ]
  },
  {
    "objectID": "todo.html#reporting-reproducibility",
    "href": "todo.html#reporting-reproducibility",
    "title": "TODO List",
    "section": "Reporting & Reproducibility",
    "text": "Reporting & Reproducibility\n\nVersion control\nQuarto",
    "crumbs": [
      "TODO",
      "TODO List"
    ]
  },
  {
    "objectID": "todo.html#miscellaneous",
    "href": "todo.html#miscellaneous",
    "title": "TODO List",
    "section": "Miscellaneous",
    "text": "Miscellaneous\n\nSimulations with {DrWatson}\n{Revise}\n\nBasics functionality\nUsing for single scripts\nUsing for modules/packages\nAdding to startup.jl file\n\nWriting functions\n\nTyping arguments\n\nParametric types\n\nTesting\nDocumentation\nMultiple dispatch\nFunction/Type piracy\n\nDeveloping packages\n\nModules\nNamespaces\nDev local packages\nPackage registry with {LocalRegistry}\n{PkgTemplates}\n\nPerformance\n\nMemory access (column-major vs row-major, @views())\nProfiling\nMulti-threading\nMulti-processing\nBenchmarking\n{Bumper}\n{DispatchDoctor}\nPipelines with {Dagger}\n\nR interoperability\n\n{RCall}\n{JuliaCall}",
    "crumbs": [
      "TODO",
      "TODO List"
    ]
  },
  {
    "objectID": "misc.html",
    "href": "misc.html",
    "title": "Misc",
    "section": "",
    "text": "Namespaces",
    "crumbs": [
      "TODO",
      "Misc"
    ]
  },
  {
    "objectID": "misc.html#namespaces",
    "href": "misc.html#namespaces",
    "title": "Misc",
    "section": "",
    "text": "About Namespaces\nA namespace is the term used to describe how functions belong to different environments. Each module (and therefore package) has its own namespace. When we open up the REPL, we are operating in the Main namespace, and hitting tab on the keyboard populates the autocomplete with all the functions and constants that have been exported by Julia packages into the Main namespace. For example, one suggestion is the √ operator. Examining the methods of the square root operator, we can see that it has been defined in multiple locations of Base (which you can think of as a package that wraps around a number of core packages required to provide necessary minimum functionality for the language, such as Math and JuliaSyntax) and other packages (such as LinearAlgebra).\n\nmethods(√)\n\n# 19 methods for generic function sqrt from \u001b[90mBase\u001b[39m: sqrt(x::BigFloat) in Base.MPFR at mpfr.jl:636  sqrt(::Missing) in Base.Math at math.jl:1580  sqrt(a::Float16) in Base.Math at math.jl:1558  sqrt(x::BigInt) in Base.MPFR at mpfr.jl:644  sqrt(a::ComplexF16) in Base.Math at math.jl:1559  sqrt(A::LinearAlgebra.UnitUpperTriangular{T, S} where S&lt;:AbstractMatrix{T}) where T in LinearAlgebra at /Users/cfa5228/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/LinearAlgebra/src/triangular.jl:2159  sqrt(A::LinearAlgebra.Hermitian{T, S} where S&lt;:(AbstractMatrix{&lt;:T}); rtol) where T&lt;:Complex in LinearAlgebra at /Users/cfa5228/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/LinearAlgebra/src/symmetric.jl:796  sqrt(D::LinearAlgebra.Diagonal) in LinearAlgebra at /Users/cfa5228/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/LinearAlgebra/src/diagonal.jl:713  sqrt(x::Union{Float32, Float64}) in Base.Math at math.jl:685  sqrt(x::Real) in Base.Math at math.jl:1575  sqrt(A::LinearAlgebra.UpperTriangular) in LinearAlgebra at /Users/cfa5228/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/LinearAlgebra/src/triangular.jl:2158  sqrt(A::LinearAlgebra.LowerTriangular) in LinearAlgebra at /Users/cfa5228/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/LinearAlgebra/src/triangular.jl:2177  sqrt(A::LinearAlgebra.Transpose{T, &lt;:AbstractMatrix} where T) in LinearAlgebra at /Users/cfa5228/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/LinearAlgebra/src/dense.jl:908  sqrt(J::LinearAlgebra.UniformScaling) in LinearAlgebra at /Users/cfa5228/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/LinearAlgebra/src/uniformscaling.jl:173  sqrt(A::LinearAlgebra.Adjoint{T, &lt;:AbstractMatrix} where T) in LinearAlgebra at /Users/cfa5228/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/LinearAlgebra/src/dense.jl:907  sqrt(A::LinearAlgebra.UnitLowerTriangular) in LinearAlgebra at /Users/cfa5228/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/LinearAlgebra/src/triangular.jl:2178  sqrt(A::Union{LinearAlgebra.Hermitian{T, S}, LinearAlgebra.Symmetric{T, S}} where S; rtol) where T&lt;:Real in LinearAlgebra at /Users/cfa5228/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/LinearAlgebra/src/symmetric.jl:785  sqrt(A::AbstractMatrix{T}) where T&lt;:Union{Real, Complex} in LinearAlgebra at /Users/cfa5228/.julia/juliaup/julia-1.10.4+0.aarch64.apple.darwin14/share/julia/stdlib/v1.10/LinearAlgebra/src/dense.jl:877  sqrt(z::Complex) in Base at complex.jl:527 \n\n\nEach of these method definitions has been exported into the Main namespace so they can be used without requiring qualification (i.e., Math.√ and LinearAlgebra.√).\n\n\nNamespace Management\nIn the above examples, the square root function was available from when we first opened up Julia. When we are writing code, this may not be the case, and in fact, we may not want it to be the case. Let’s imagine we want to load a data file from the data/ directory. As seen before, we can do this using the datadir() function from the {DrWatson} package. We may not want to load all the functions {DrWatson} exports into our Main namespace (one reason being that we may be concerned about a conflict with another package using the same name and argument types, and we want to be explicit about where our function comes from). In this situation, there are two possible solutions:\n\nusing DrWatson: datadir; datadir(file.jl)\nusing DrWatson: DrWatson; DrWatson.datadir(file.jl)\n\nIn option 1) we are only loading the datadir() function into the Main namespace, but none of the other functions defined and exported by {DrWatson}. This is a useful compromise when we think we will need to use the datadir() function multiple times in a file/script as it reduces unnecessarily typing the package name for each function use, while also making it explicit which package the datadir() function was defined in. In reality, what we are actually calling is Main.datadir(), as the datadir() function now belongs to the Main namespace. Sometimes, though, option 1) isn’t sufficient, such as when we expect a conflict (method ambiguity) to arise.\nIn option 2), we do not load datadir() into the Main namespace, instead, leaving it contained within DrWatson’s namespace (remember, each package has its own namespace). To use the function, we need to specify that it is defined in the namespace of the {DrWatson} package, which we do using the package name followed by a period. Much like how we were calling Main.datadir() in option 1), what we are actually doing is loading the DrWatson package name into the Main namespace, and the same syntactic sugar is happening, so option 2) is really calling Main.DrWatson.datadir(file.jl). You can think of this as the {DrWatson} package being treated as a submodule of Main (see the module section for more information about submodules).",
    "crumbs": [
      "TODO",
      "Misc"
    ]
  },
  {
    "objectID": "misc.html#modules",
    "href": "misc.html#modules",
    "title": "Misc",
    "section": "Modules",
    "text": "Modules",
    "crumbs": [
      "TODO",
      "Misc"
    ]
  },
  {
    "objectID": "misc.html#result-types",
    "href": "misc.html#result-types",
    "title": "Misc",
    "section": "Result Types",
    "text": "Result Types",
    "crumbs": [
      "TODO",
      "Misc"
    ]
  },
  {
    "objectID": "misc.html#plotting",
    "href": "misc.html#plotting",
    "title": "Misc",
    "section": "Plotting",
    "text": "Plotting",
    "crumbs": [
      "TODO",
      "Misc"
    ]
  }
]