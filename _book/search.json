[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "JuliaEpiHandbook",
    "section": "",
    "text": "About This Project\nThe purpose of this book is to create a similar document as the excellent EpiRHandbook for epidemiologist who are interested in becoming Julia language users. Most people in epidemiology and statistics use R, Stata, or SAS. There are still plenty of people who exclusively use Excel to great results. That’s OK, and I’m not trying to tell you that those options are bad and you should convert to Julia immediately. But there are some advantages that I think make it an attractive option for epidemiologists to consider."
  },
  {
    "objectID": "index.html#who-is-this-for-pre-requisite-knowledge",
    "href": "index.html#who-is-this-for-pre-requisite-knowledge",
    "title": "JuliaEpiHandbook",
    "section": "Who Is This For & Pre-Requisite Knowledge?",
    "text": "Who Is This For & Pre-Requisite Knowledge?\nBecause this book aims to provide ground-up instruction on using Julia as an epidemiologist, it does not assume any prior coding experience. Many people get started with Excel analysis, and this book tries to provide a new path that will be easier and more reliable for those individuals moving forward. As a result, the earlier chapters will lay out fundamental concepts of Julia and best practices for setting up a project, including concepts on version control and Git. But if you’ve got experience with R (or another language), then I hope to try and draw parallels and examples that will help speed up your learning.\nThe purpose of this book is not to teach you how to write the most performant code, though we will cover some key concepts as we go along, nor show you ever way to do a particular task. Neither is it’s purpose to teach you to become a Julia developer. There are many other resources that are better suited for those purposes, and I’ve tried to include links where appropriate. Instead, the goal is to help you get started with Julia, working through problems that you might encounter in your day-to-day work, providing you with the tools to carry out your work as an epidemiologist, and sufficient Julia knowledge to know how to research and think your way through other obstacles you may encounter. As a result, this book will make choices that prioritize readability and reproducibility over performance, because they are more important when you are getting started. Unlike Python, which takes the approach that there should only be one obvious way to complete a task, Julia provides the user with more flexibility because it is so fast that there are often multiple solutions that are similarly performant, and which one to use comes down to a stylistic choice. Where I make a deliberate choice, I will try to explain why I made that choice, and refer you to alternative approaches that you can explore on your own as you become more proficient with computational epidemiology and Julia.\nNot only will this book help you learn how to use Julia, but I hope that it will also help teach you how to think about problems that are relevant to you in a way that will help you solve them in Julia. Like everything in life, you will not be great at this immediately, and you may even be slower at problem solving with Julia that you are with your current tool. But, with practice, you will get better and faster, and you will soon be able to solve problems that you could not have solved before!"
  },
  {
    "objectID": "index.html#built-with",
    "href": "index.html#built-with",
    "title": "JuliaEpiHandbook",
    "section": "Built With",
    "text": "Built With\n\nQuarto\nJulia"
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "JuliaEpiHandbook",
    "section": "Contact",
    "text": "Contact\nYou can contact me via my email: “arnold dot crk at gmail dot com”."
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "JuliaEpiHandbook",
    "section": "Contributing",
    "text": "Contributing\nIf you see any issues, please open an Issue or Discussion on the book’s GitHub page. Or, if you know Git, you can open a Pull Request to fix the issue directly, which is even better!\n\n\n\n\n\n\nTip\n\n\n\nYou can directly go to the code for each page by clicking the “Edit this page on GitHub” link at the bottom of each page’s TOC on the right. This can be useful if you would like to point out an issue or propose a change.\n\n\nIf you are interested in contributing text, please email me and we can make it happen!"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "JuliaEpiHandbook",
    "section": "Acknowledgements",
    "text": "Acknowledgements\n\nEpiRHandbook for inspiration"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "JuliaEpiHandbook",
    "section": "License",
    "text": "License\nThis work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License."
  },
  {
    "objectID": "motivations-background.html#background",
    "href": "motivations-background.html#background",
    "title": "What Is Julia and Why Should I Care",
    "section": "Background",
    "text": "Background\nNow that we’ve gotten a sense of what this book aims to achieve, let’s take a step back and talk about what Julia is, and why you should care. Julia is a relatively new free programming language that was first released in 2012 by some computational scientists at MIT, and has been growing in popularity ever since. It’s a general purpose language, meaning that it can be used for pretty much anything, but it’s particularly well suited for scientific computing, and is often compared to R, Python, and Matlab. There are plenty of reasons why you might want to learn Julia, but the main ones are that it’s fast, easy to learn (as far as coding goes), and has a great community. And with that, let’s dive in to the benefits and drawbacks of Julia!"
  },
  {
    "objectID": "motivations-background.html#motivation",
    "href": "motivations-background.html#motivation",
    "title": "What Is Julia and Why Should I Care",
    "section": "Motivation",
    "text": "Motivation\n\nWhy write a book for Julia?\nWhat’s wrong with R, or Stata, or Python, or (insert your favourite language here)?\n\nExcellent questions. I use R every day and think it’s a great language for epidemiology, statistics, visualization, and many more things. But it’s not exactly a fast language. And for me, and plenty more epidemiologists, that can be a problem when working with large data sets or running simulations. Large data is less of an issue because package developers often have already rewritten the core code in a faster language, typically C++. But this is less that ideal if you want to look under the hood as it requires you to learn a second language (and C++ isn’t exactly known for being friendly to newcomers). The bigger issues, though, come when you need to write something from scratch, such as creating a large and complex simulation model, R is sometimes just too slow to actually run on your laptop in a reasonable time period, breaking up the development workflow. In this instance, you have two options: 1) suck it up and just hope your first attempt at the code was correct and don’t need to change anything, or 2) learn and rewrite your slow code in something faster. This is the classic “2 language problem”, and there are plenty of excellent articles on this, such as this Nature Methods article about Julia for Biologists, and this blog post from the creators of Julia.\n\nOK, but not everyone needs to run big simulations or work with big data. Why learn Julia over R in that case?\n\nAnother good question that covers a decent chunk of working epidemiologists. If you don’t need performance, I think it’s a slightly less compelling case, but there are still plenty of good reasons to think about learning Julia.\nFirstly, it has an excellent syntax and design structure that makes it one of the easier (and fun!) languages out there to learn. It’s incredibly helpful to be able to think in plain language and pretty much just implement that in code - for loops are quick so you don’t need to do mental gymnastics to think about how to vectorize your code. I know that’s a jargony term that might not mean anything to you, but in slower languages, you have to think about more abstract and unintuitive ways of implementing what you want, whereas much of your instincts are idiomatic in Julia i.e. are a fast and preferred implentation. This means that you can do more things more easily in Julia than you could in R, which has shoehorned many capabilities into it with varying degrees of success. Metaprogramming and multiple-dispatch are killer features that are core to how Julia works, and will eventually allow you to write simple and interpretable code that would require tons of if statements that result in hard-to-read code in other languages, such as R. And the package manager is excellent, making it so easy to create fully reproducible code, whereas R and Python almost seem to be it intentionally hard to do.\nSecondly, and this is a pretty big one, but Julia is a general purpose language whose syntax is rather similar to Python a lot of the time. Whether we like it or not, Python isn’t going anywhere. There’s a decent chance that at some point you will come across some Python code, or maybe even need to write some for a collaboration, and knowing Julia will make it pretty simple to pick up the key points, without needing to rely on using slow Python in your day-to-day life.\nFinally, if you need it, Julia is first-rate when it comes to scientific computing. A lot of aspects of epidemiology rely on differential equations, math, and increasingly, machine learning. Not only is there the excellent SciML ecosystem that houses a huge collection of state-of-the-art ODE solvers, but also, because Unicode symbols are valid code in Julia, you can literally write mathematical equations that you lifted out of a paper or book, and there’s a decent chance it’ll run with only minor modifications!"
  },
  {
    "objectID": "motivations-background.html#it-cant-all-be-sunshine-and-roses",
    "href": "motivations-background.html#it-cant-all-be-sunshine-and-roses",
    "title": "What Is Julia and Why Should I Care",
    "section": "It Can’t All Be Sunshine and Roses",
    "text": "It Can’t All Be Sunshine and Roses\nCorrect. Julia is by no means perfect, and you will have to decide if the benefits outweigh the tradeoffs (I believe they do for a lot of us)!\nFirstly, while Julia has an active, friendly, and very enthusiatic community that is often willing to help when you get stuck, it is a relatively new language so support will be more limited than can be found in others. Related to this, not everything you will want to do will have a perfect pre-built package ready to go. Most of the time, this actually isn’t too big a deal as it’s either simple enough that you can quickly figure it out, or complex enough that you probably want to have ownership over the implementation, but occassionally it is genuinely an issue. Both of these issues, however, are improving rapidly as the Julia userbase grows and more people share their questions, expertise, and even turning solutions into packages that can be shared!\nThe next common stumbling block is related to performance. Despite what I said about it being a very fast language, it’s quite a bit slower at the start of a session than R or Python, for example. This is known as the “Time to first X” (TTFX) problem, and while everything will be almost instantaneous the second time you run it, it can be annoying. Thankfully, with the recent release of Julia 1.9.0, this is effectively a problem of the past, with most Julia sessions loading packages and creating your first plot within a few seconds, not a minute.\nAnd the last main issue with Julia is that packages aren’t always documented as clearly as in other languages, and debugging can be a painful experience. Every package is different, and while the Documenter.jl package does an excellent job of standardizing package documentation, unfortuately not everyone does a great job of writing robust tests and guides to help the user. Sometimes you just need to dig in the weeds to figure something out.\nBut, that’s part of the motivation for writing this book. For a lot of what we do as epidemiologists, we can work with very established packages that have solid code bases, so we won’t need to worry too much about the code quality as it’s already been tested by thousands of individuals. Instead, this book is to help guide someone new to Julia through the core tasks of epidemiology, and show you how to use the tools that exist in the community, but may have confusing documentation to someone new to the language, or even programming in general."
  },
  {
    "objectID": "technical-background.html#general-formatting",
    "href": "technical-background.html#general-formatting",
    "title": "Keywords, Code, and Other Formatting",
    "section": "General Formatting",
    "text": "General Formatting\nThroughout the book, you’ll see some keywords, code, and other points that I’ll try to delineate with the following formatting:\n\n\n\n\n\n\nNote\n\n\n\nThis will be a note, and will be used to highlight important points, or to provide additional information.\n\n\n\n\n\n\n\n\nTip\n\n\n\nThis will be used to highlight a useful tip.\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThis will provide a warning that you may get an unexpected result if you’re not careful.\n\n\n\ncode will be used to highlight code.\n{package.function()} will be used to denote a specific package and function, e.g., {DataFrames.subset()} denotes the subset() function from the {DataFrames} package. Some languages use a different convention, such as package::function() in R, but so where relevant, I will do my best to provide the correct syntax.\nkeywords will be used to highlight keywords and phrases, e.g., Git or GitHub.\n\nactions will also be highlighted in this way, e.g., commits or pushed being the result of the code git commit or git push\n\nfiles will be used to highlight file names, e.g., README.md or LICENSE.\nitalics will be used for emphasis in certain circumstances, e.g., signifying a question from an interactive terminal command."
  },
  {
    "objectID": "technical-background.html#packages",
    "href": "technical-background.html#packages",
    "title": "Keywords, Code, and Other Formatting",
    "section": "Packages",
    "text": "Packages\nThroughout this book, I will use a number of packages to help with the analysis and visualization of data. For each section, I will provide a list of the packages used in a particular set of analyses at the top of the page. The Julia language has an excellent package manager that makes it easy to install and use packages, and also share projects and collaborate with others without running into issues regarding dependencies that often plagues other languages. In the next section, I will walk through the process of getting started with Julia, and therefore, the process of installing packages, but below you can see the full list of packages and the installed version of Julia used in this book.\n\nversioninfo()\n\nJulia Version 1.9.0\nCommit 8e630552924 (2023-05-07 11:25 UTC)\nPlatform Info:\n  OS: macOS (arm64-apple-darwin22.4.0)\n  CPU: 8 × Apple M1\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, apple-m1)\n  Threads: 5 on 4 virtual cores\nEnvironment:\n  JULIA_NUM_THREADS = auto\n\n\n\nusing Pkg\nPkg.status()\n\nStatus `~/Documents/Repos/JuliaEpiHandbook/Project.toml`\n  [336ed68f] CSV v0.10.10\n  [13f3f980] CairoMakie v0.10.5\n  [a93c6f00] DataFrames v1.5.0\n  [1313f7d8] DataFramesMeta v0.14.0\n  [634d3b9d] DrWatson v2.12.5\n  [7073ff75] IJulia v1.24.0\n  [98e50ef6] JuliaFormatter v1.0.29\n  [295af30f] Revise v3.5.2"
  },
  {
    "objectID": "technical-background.html#code-style",
    "href": "technical-background.html#code-style",
    "title": "Keywords, Code, and Other Formatting",
    "section": "Code Style",
    "text": "Code Style\nThere are many different ways to write code, and many different styles. But, in the interest of consistency and ease of collaboration, I would strongly recommend you use the {JuliaFormatter} package to format your code according to a specific style guide. In this book, I will use a lightly modified version of the Blue style guide, and you can see the specific changes to the default style in the .JuliaFormatter.toml file in the root directory of this book’s GitHub repository. In the next section, I will discuss how you can use the {JuliaFormatter} package to format your code."
  },
  {
    "objectID": "install-julia.html#key-terms",
    "href": "install-julia.html#key-terms",
    "title": "Setting Up Julia",
    "section": "Key Terms",
    "text": "Key Terms\n\nVSCode: Visual Studio Code is a very popular open source code editor. It is free and available for Windows, Mac, and Linux. It is also the recommended editor for Julia and is well supported by the Julia community, with a number of extensions available to make the experience even better.\nREPL: The Julia REPL is the Julia Read-Eval-Print-Loop. This is the interactive command line interface for Julia. When you start Julia in the command line (terminal in Mac/Linux, command prompt in Windows), you are in the REPL, and it is a common way to interact with Julia.\nPackage: A package is a collection of code that can be used to extend the functionality of Julia and complete specific tasks. Packages are installed using the Pkg package manager.\nObject: An object is anything that you can create using code. This may be as simple as a number or a sentence (a string object), or as complex as a model or a plot."
  },
  {
    "objectID": "install-julia.html#getting-set-up",
    "href": "install-julia.html#getting-set-up",
    "title": "Setting Up Julia",
    "section": "Getting Set Up",
    "text": "Getting Set Up\n\nInstalling Julia\nThe first step to using Julia is to install it on your computer. There are a couple of different methods you can use to do this. The easiest way to get started is to directly download the latest stable Julia release from https://julialang.org/downloads/. This will get you up and running, but will be a bit more difficult to manage in the long run when you want to update Julia to newer versions.\nIf you are willing to put a tiny bit more effort in to save yourself time later, I would recommend installing Julia using the Juliaup tool. This is a small cross-platform installer that can install Julia, as well as manage multiple versions on your computer, which is incredibly helpful when you want to update to a newer Julia version, or test out a new release candidate without breaking your existing Julia installation. You can find the full instructions here: https://github.com/JuliaLang/juliaup, but in brief, install Juliaup, and then run the following command in your terminal (Mac/Linux) or command prompt (Windows):\njuliaup add release # Installs the latest stable release\njuliaup default release # Not necessary with only one installed version, but sets the latest stable release as the default Julia version\nTo test that Julia has been installed correctly, open a terminal (Mac/Linux) or command prompt (Windows) and type julia. If Julia has been installed correctly, you should see something like the following:\n\n\n\nThe Julia REPL\n\n\nIf so, congratulations, you have successfully installed Julia, and you are now in the REPL. You could start working on Julia from here, but we’ll take a quick detour to install VSCode, which will make your life a lot easier. To quit the REPL, type exit() and press enter. You can also type Ctrl + D to exit the REPL.\n\nTrouble Shooting\nIf your Julia installation could not be found, it is likely an issue with your PATH variable. This is a variable that tells your computer where to look for programs when you type them into the command line. If you used Juliaup to install Julia and you are using a Mac or Linux, you might need to add the following line to your .bashrc or .zshrc file, depending of whether your computer uses bash or zsh.\nexport PATH=\"$HOME/.juliaup/bin/:$PATH\"\n\n\n\n\n\n\nTip\n\n\n\nIf you don’t know if your computer is using bash or zsh, you can check by typing echo $SHELL into the command line. This will print the shell that your computer is using; in my case /bin/zsh. You should also type ls -a ~ into the command line to see if you have an existing .bashrc or .zshrc file. If you do not have either, you can create the one relevant to your computer by typing touch ~/.bashrc or touch ~/.zshrc.\n\n\nIf you are using Juliaup on Windows, and installed using the recommended pathways (Windows store or winget command), you will need to edit your PATH variable using the following the steps detailed here, and make sure you have the following path:\n%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps\n\n\n\nInstalling VSCode\nNow you have Julia installed, you need a code editor to write your Julia code in. There are a number of different options available, but the most popular is VSCode. You can download VSCode from https://code.visualstudio.com/download. Once you have VSCode installed, you will need to install the Julia extension. You can do this by opening this link and clicking “Install”, which will redirect you to VSCode to finish the install process. Alternatively, you can open VSCode, click the extensions icon in the left sidebar of VSCode (the one that looks like 4 blocks), and search for “Julia”.\n\n\n\nVSCode Julia Extension\n\n\nOnce you have installed the Julia extension, you’re ready to start writing Julia code!\nThe first thing you should do is open a Julia REPL within VSCode. To do this, open the VSCode command palette and type “Julia: Start REPL”.\n\n\n\n\n\n\nNote\n\n\n\nThe command palette is a really useful feature of VSCode that allows you to search for and run any command available in VSCode. You can open the command palette by pressing Ctrl + Shift + P on Windows or Linux, or Cmd + Shift + P on Mac. For more tips on how to navigate and use VSCode, see the VSCode documentation.\n\n\n\n\n\nStarting a Julia REPL in VSCode\n\n\nThis will open up a new section in VSCode that contains a Julia REPL within the “Integrated Terminal” of VSCode.\n\n\n\nIntegrated VSCode Julia Terminal\n\n\nYou can give Julia a quick spin by typing 1 + 1 into the REPL and pressing enter.\n\nTrouble Shooting\nIf your Julia installation could not be found by VSCode, but it works in the terminal, the VSCode Julia extension is having trouble find where Julia is installed.\nTo fix this, first, find your Julia installation. On Mac or Linux, you can do this by typing which julia into the terminal. On Windows, you can do this by typing where julia into the command prompt.\nIf you installed Julia using Juliaup, you should see something like the following:\n$ which julia\n\n/Users/username/.juliaup/bin/julia\nTake the output of this command and paste it into the VSCode settings. To do this, open the VSCode settings by clicking on the cog icon in the bottom left of the VSCode window, and then clicking “Settings”, or by using the command palette to navigate to “Preferences: Open Settings (UI)”. Here, search for “Julia Executable Path” and paste the output of the which/where julia command into the text box. this is a \n\n\n\nVSCode Basics\nHopefully at this point you have VSCode installed and the Julia extension working. Now’s let’s get familiar with VSCode itself, that way we can focus on learning Julia in the rest of the book, rather than getting stuck on the editor.\n\nThe VSCode User Interface\nA detailed description of the VSCode user interface is beyond the scope of this book (more details can be found here), but there are a few key features that you should be aware of.\n\n\nVideo\nVSCode User Interface\n\n\nAs you can see in the clip above, it is possible to move the main editing blocks around so you can have multiple files open at once (or even multiple views of the same file at different lines of code). Typically, I like to have my code open in one editing block and have the plots display to the right side of the screen.\nTo the left of the editing blocks is the primary sidebar, which contains a number of different panels. The first one, which I have open, is the “Explorer” panel, which shows the files and folders in the current Workspace. A Workspace in VSCode is a collection of folders and files that you want to group together into one project. This is a really useful feature of VSCode as it allows you to also have Workspace-specific settings, which can be useful when working on different projects. To get started with a new Workspace, all you have to do is open a folder in VSCode, as typically it’s a good rule of thumb to have one overarching folder per project. You can do this with Cmd + O on Mac or Ctrl + O on Windows or Linux, or by clicking “File” in the top left of the VSCode window and then clicking “Open Folder”. After doing so, you will see the folder name appear in the top of the “Explorer” panel, with all contained files and folders displayed below.\nFurther down in the sidebar, you will see there is a logo with three circles (which I click on in the video). This is the Julia extension, and will show you the Julia Workspace at the top, which contains every object that you have run and created. Below that is the Documentation section, which is where can search for and view the documentation for any Julia function or type (as long as the function is within one of the packages you have loaded). Finally, below that is the Plot Navigator section, which is where you can view the list of plots that you have created in Julia, and clicking on a plot number will update the plot viewer appropriately.\nAt the bottom of the screen, you will see the Integrated Terminal panel, which is where you can run Julia code, as well as the Problems panel, which will show you any errors or warnings that VSCode has detected in your code. Some other tools can be seen here, but they are not particularly important for now.\nFinally, at the very bottom of the screen is the Status Bar, which shows you the current branch of your git repository (if you have one), the current Julia environment, and some other miscellaneous information."
  },
  {
    "objectID": "install-julia.html#bonus-set-up",
    "href": "install-julia.html#bonus-set-up",
    "title": "Setting Up Julia",
    "section": "Bonus Set Up",
    "text": "Bonus Set Up\n\nFonts\nIf you want to make your code look as good as possible, you should install a font that supports rendering of ligatures and Unicode characters, as Julia often uses them. Ligatures are special characters that are used to combine multiple characters into one. For example, ==> is a ligature that with particular fonts will be rendered as a double arrow ⟹, which can look nicer and be easier to read. Examples of Unicode characters are Greek letters, such as θ, β, γ, σ, δ etc., which are often used in mathematical notation, and because Julia supports Unicode characters, you can use them in your code! This is very useful when coding up some mathematical formulae, as you can use the actual symbols rather than having to write out the name of the symbol (though this is not always recommended as it can make your code harder to read to those unfamiliar with the formulae).\nAll this being said, JuliaMono is a font designed specifically for Julia, and is a great choice for writing Julia code. You can more information at https://juliamono.netlify.app/, along with detailed installation instructions."
  },
  {
    "objectID": "julia-basics.html#key-terms",
    "href": "julia-basics.html#key-terms",
    "title": "Julia Basics",
    "section": "Key Terms",
    "text": "Key Terms\n\nREPL: The Julia REPL is the Julia Read-Eval-Print-Loop. This is the interactive command line interface for Julia. When you start Julia in the command line (terminal in Mac/Linux, command prompt in Windows), you are in the REPL, and it is a common way to interact with Julia.\nPackage: A package is a collection of code that can be used to extend the functionality of Julia and complete specific tasks. Packages are installed using the Pkg package manager.\nObject: An object is anything that you can create using code. This may be as simple as a number or a sentence (a string object), or as complex as a model or a plot.\nFunction: A function is a block of code that performs a specific task. Functions are called by name and can take arguments, before completing some computation and returning a value or object. Sometimes functions are written and called for their side effects, i.e. they do not directly return an object, but instead perform some action.\nMethod: A method is a specific implementation of a function.\nMultiple Dispatch: Multiple dispatch is a really exciting feature of Julia, but also one that is more difficult to understand for newer programmers. The basic premise is that in Julia, how functions behave depends on the types of the arguments that are passed to them. For example, the * operator (function) will behave differently if you try to multiply two integers, two floats (numbers with decimals), two matrices, any combination of these etc. Each of these different behaviors is a different method of the * function."
  },
  {
    "objectID": "julia-basics.html#additional-resources",
    "href": "julia-basics.html#additional-resources",
    "title": "Julia Basics",
    "section": "Additional Resources",
    "text": "Additional Resources\n\nScientific Computing for the Rest of Us\nJulia Academy\nPumasAI Tutorials\nJulia Data Science\nThink Julia\nDoggo JL\nJulia Documentation\nJulia For Economists Video Series\nAdvanced Scientific Computing: Producing Better Code\nQuantitative Economics with Julia"
  }
]